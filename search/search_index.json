{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spatial-graph","text":"<p><code>spatial-graph</code> provides a data structure for directed and undirected graphs, where each node has an nD position (in time or space).</p> <p>It leverages well-in-time compiled C++ code for efficient graph operations, coupled with an rtree implementation for fast spatial queries.</p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Support for arbitrary number of dimensions</li> <li>Typed node identifiers and attributes<ul> <li>Any fixed-length type that is supported by <code>numpy</code></li> </ul> </li> <li>Efficient node/edge queries by<ul> <li>ROI</li> <li>kNN (by points / lines)</li> </ul> </li> <li>numpy-like interface for efficient:<ul> <li>Graph population and manipulation</li> <li>Query results</li> <li>Attribute access</li> </ul> </li> <li>Minimal memory footprint</li> <li>Minimal dependencies</li> <li>PYX API for graph algorithms in C/C++</li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Graph creation:</p> <pre><code>graph = sg.SpatialGraph(\n    ndims=3,\n    node_dtype=\"uint64\",\n    node_attr_dtypes={\"position\": \"double[3]\"},\n    edge_attr_dtypes={\"score\": \"float32\"},\n    position_attr=\"position\",\n)\n</code></pre> <p>Adding nodes/edges:</p> <pre><code>graph.add_nodes(\n    np.array([1, 2, 3, 4, 5], dtype=\"uint64\"),\n    position=np.array(\n        [\n            [0.1, 0.1, 0.1],\n            [0.2, 0.2, 0.2],\n            [0.3, 0.3, 0.3],\n            [0.4, 0.4, 0.4],\n            [0.5, 0.5, 0.5],\n        ],\n        dtype=\"double\",\n    ),\n)\n\ngraph.add_edges(\n    np.array([[1, 2], [3, 4], [5, 1]], dtype=\"uint64\"),\n    score=np.array([0.2, 0.3, 0.4], dtype=\"float32\"),\n)\n</code></pre> <p>Query nodes/edges in ROI:</p> <pre><code># nodes/edges will be numpy arrays of dtype uint64 and shape (n,)/(n, 2)\nnodes = graph.query_nodes_in_roi(np.array([[0.0, 0.0, 0.0], [0.25, 0.25, 0.25]]))\nedges = graph.query_edges_in_roi(np.array([[0.0, 0.0, 0.0], [0.25, 0.25, 0.25]]))\n</code></pre> <p>Query nodes/edges by position:</p> <pre><code>nodes = graph.query_nearest_nodes(np.array([0.3, 0.3, 0.3]), k=3)\nedges = graph.query_nearest_edges(np.array([0.3, 0.3, 0.3]), k=3)\n</code></pre> <p>Access node/edge attributes:</p> <pre><code>node_positions = graph.node_attrs[nodes].position\nedge_scores = graph.edge_attrs[edges].score\n</code></pre> <p>Delete nodes/edges:</p> <pre><code>graph.remove_nodes(nodes[:1000])\n</code></pre> <p>See the API documentation for more details.</p>"},{"location":"reference/spatial_graph/","title":"spatial_graph","text":""},{"location":"reference/spatial_graph/#spatial_graph","title":"spatial_graph","text":"<p>Modules:</p> <ul> <li> <code>dtypes</code>           \u2013            </li> <li> <code>graph</code>           \u2013            </li> <li> <code>rtree</code>           \u2013            </li> <li> <code>spatial_graph</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>Base class for directed graph instances.</p> </li> <li> <code>Graph</code>           \u2013            <p>Base class for undirected graph instances.</p> </li> <li> <code>GraphBase</code>           \u2013            <p>Base class for compiled graph instances.</p> </li> <li> <code>LineRTree</code>           \u2013            </li> <li> <code>SpatialDiGraph</code>           \u2013            <p>Base class for directed spatial graph instances.</p> </li> <li> <code>SpatialGraph</code>           \u2013            <p>Base class for undirected spatial graph instances.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>create_graph</code>             \u2013              <p>Convenience factory function to create a graph instance.</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph","title":"DiGraph","text":"<pre><code>DiGraph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>GraphBase</code></p> <p>Base class for directed graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph","title":"Graph","text":"<pre><code>Graph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>GraphBase</code></p> <p>Base class for undirected graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase","title":"GraphBase","text":"<pre><code>GraphBase(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>Base class for compiled graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree","title":"LineRTree","text":"<pre><code>LineRTree(item_dtype, coord_dtype, dims)\n</code></pre> <p>               Bases: <code>RTree</code></p> <p>Methods:</p> <ul> <li> <code>insert_line</code>             \u2013              <p>Convenience function to insert a single line. To insert multiple</p> </li> <li> <code>insert_lines</code>             \u2013              <p>Insert a list of lines.</p> </li> </ul> Source code in <code>src/spatial_graph/rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype, coord_dtype, dims):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line","title":"insert_line","text":"<pre><code>insert_line(line, start, end)\n</code></pre> <p>Convenience function to insert a single line. To insert multiple lines in bulk, please use the faster <code>insert_lines</code>.</p> <p>Args:</p> <pre><code>line (`item_dtype`):\n\n    The line identifier (as passed as the `item_dtype` to the\n    constructor).\n\nstart (`ndarray`, shape `(d,)`):\n\n    The coordinates of the start of the line.\n\nend (`ndarray`, shape `(d,)`):\n\n    The coordinates of the end of the line.\n</code></pre> Source code in <code>src/spatial_graph/rtree/line_rtree.py</code> <pre><code>def insert_line(self, line, start, end):\n    \"\"\"Convenience function to insert a single line. To insert multiple\n    lines in bulk, please use the faster `insert_lines`.\n\n    Args:\n\n        line (`item_dtype`):\n\n            The line identifier (as passed as the `item_dtype` to the\n            constructor).\n\n        start (`ndarray`, shape `(d,)`):\n\n            The coordinates of the start of the line.\n\n        end (`ndarray`, shape `(d,)`):\n\n            The coordinates of the end of the line.\n    \"\"\"\n    lines = np.array([line], dtype=self.item_dtype.base)\n    starts = start[np.newaxis]\n    ends = end[np.newaxis]\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines","title":"insert_lines","text":"<pre><code>insert_lines(lines, starts, ends)\n</code></pre> <p>Insert a list of lines.</p> <p>Args:</p> <pre><code>lines (`ndarray`, shape `(n, [m])`):\n\n    Array containing the line identifiers (as passed as the\n    `item_dtype` to the constructor). If the identifiers are an\n    array of size `m`, the expected shape is `(n, m)` where `n` is\n    the number of lines, otherwise the shape is just `(n,)`.\n\nstarts (`ndarray`, shape `(n, d)`):\n\n    The coordinates of the start of each line.\n\nends (`ndarray`, shape `(n, d)`):\n\n    The coordinates of the end of each line.\n</code></pre> Source code in <code>src/spatial_graph/rtree/line_rtree.py</code> <pre><code>def insert_lines(self, lines, starts, ends):\n    \"\"\"Insert a list of lines.\n\n    Args:\n\n        lines (`ndarray`, shape `(n, [m])`):\n\n            Array containing the line identifiers (as passed as the\n            `item_dtype` to the constructor). If the identifiers are an\n            array of size `m`, the expected shape is `(n, m)` where `n` is\n            the number of lines, otherwise the shape is just `(n,)`.\n\n        starts (`ndarray`, shape `(n, d)`):\n\n            The coordinates of the start of each line.\n\n        ends (`ndarray`, shape `(n, d)`):\n\n            The coordinates of the end of each line.\n    \"\"\"\n    # we just forward to bb insert, \"start\" and \"end\" will be used to compute\n    # the bounding box in our custom converter above\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph","title":"SpatialDiGraph","text":"<pre><code>SpatialDiGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>SpatialGraphBase</code>, <code>DiGraph</code></p> <p>Base class for directed spatial graph instances.</p> Source code in <code>src/spatial_graph/spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph","title":"SpatialGraph","text":"<pre><code>SpatialGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>SpatialGraphBase</code>, <code>Graph</code></p> <p>Base class for undirected spatial graph instances.</p> Source code in <code>src/spatial_graph/spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph","title":"create_graph","text":"<pre><code>create_graph(\n    node_dtype: str,\n    ndims: int,\n    node_attr_dtypes: Mapping[str, str] | None = ...,\n    edge_attr_dtypes: Mapping[str, str] | None = ...,\n    position_attr: str | None = ...,\n    directed: Literal[False] = ...,\n) -&gt; SpatialGraph\n</code></pre><pre><code>create_graph(\n    node_dtype: str,\n    ndims: int,\n    node_attr_dtypes: Mapping[str, str] | None = ...,\n    edge_attr_dtypes: Mapping[str, str] | None = ...,\n    position_attr: str | None = ...,\n    directed: Literal[True] = ...,\n) -&gt; SpatialDiGraph\n</code></pre><pre><code>create_graph(\n    node_dtype: str,\n    ndims: Literal[None] = ...,\n    node_attr_dtypes: Mapping[str, str] | None = ...,\n    edge_attr_dtypes: Mapping[str, str] | None = ...,\n    position_attr: str | None = ...,\n    directed: Literal[False] = ...,\n) -&gt; Graph\n</code></pre><pre><code>create_graph(\n    node_dtype: str,\n    ndims: Literal[None] = ...,\n    node_attr_dtypes: Mapping[str, str] | None = ...,\n    edge_attr_dtypes: Mapping[str, str] | None = ...,\n    position_attr: str | None = ...,\n    directed: Literal[True] = ...,\n) -&gt; DiGraph\n</code></pre> <pre><code>create_graph(\n    node_dtype: str,\n    ndims: int | None = None,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str | None = None,\n    directed: bool = False,\n) -&gt; Graph | DiGraph | SpatialGraph | SpatialDiGraph\n</code></pre> <p>Convenience factory function to create a graph instance.</p> <p>This will create the appropriate graph type based on the parameters provided. If <code>ndims</code> is specified, it will create a spatial graph; otherwise, it will create a non-spatial graph. If <code>directed</code> is True, it will create a directed graph; otherwise, it will create an undirected graph.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_util.py</code> <pre><code>def create_graph(\n    node_dtype: str,\n    ndims: int | None = None,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str | None = None,\n    directed: bool = False,\n) -&gt; Graph | DiGraph | SpatialGraph | SpatialDiGraph:\n    \"\"\"Convenience factory function to create a graph instance.\n\n    This will create the appropriate graph type based on the parameters provided.\n    If `ndims` is specified, it will create a spatial graph; otherwise, it will create\n    a non-spatial graph. If `directed` is True, it will create a directed graph;\n    otherwise, it will create an undirected graph.\n\n    Parameters\n    ----------\n    node_dtype : str\n        The data type of the nodes in the graph.\n    ndims : int or None, optional\n        The number of dimensions for spatial graphs. If None, the graph is non-spatial.\n    node_attr_dtypes : Mapping[str, str], optional\n        A mapping of node attribute names to their data types.\n    edge_attr_dtypes : Mapping[str, str], optional\n        A mapping of edge attribute names to their data types.\n    position_attr : str, optional\n        The name of the attribute that holds the position of nodes in spatial graphs.\n    directed : bool, optional\n        Whether the graph is directed or not. Defaults to False.\n    \"\"\"\n    if ndims is not None:  # Spatial graph\n        cls = SpatialDiGraph if directed else SpatialGraph\n        return cls(\n            ndims=ndims,\n            node_dtype=node_dtype,\n            node_attr_dtypes=node_attr_dtypes,\n            edge_attr_dtypes=edge_attr_dtypes,\n            position_attr=position_attr or \"position\",\n        )\n    else:\n        if position_attr is not None:  # pragma: no cover\n            warnings.warn(\n                \"'position_attr' is ignored when 'ndims' is not specified.\",\n                UserWarning,\n                stacklevel=2,\n            )\n\n        cls_ = DiGraph if directed else Graph\n        return cls_(\n            node_dtype=node_dtype,\n            node_attr_dtypes=node_attr_dtypes,\n            edge_attr_dtypes=edge_attr_dtypes,\n        )\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(node_dtype)","title":"<code>node_dtype</code>","text":"(<code>str</code>)           \u2013            <p>The data type of the nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(ndims)","title":"<code>ndims</code>","text":"(<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>The number of dimensions for spatial graphs. If None, the graph is non-spatial.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(node_attr_dtypes)","title":"<code>node_attr_dtypes</code>","text":"(<code>Mapping[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of node attribute names to their data types.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(edge_attr_dtypes)","title":"<code>edge_attr_dtypes</code>","text":"(<code>Mapping[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of edge attribute names to their data types.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the attribute that holds the position of nodes in spatial graphs.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(directed)","title":"<code>directed</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the graph is directed or not. Defaults to False.</p>"},{"location":"reference/spatial_graph/dtypes/","title":"spatial_graph.dtypes","text":""},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes","title":"spatial_graph.dtypes","text":"<p>Classes:</p> <ul> <li> <code>DType</code>           \u2013            <p>A class to represent a data type in C/C++ and Cython/PYX files.</p> </li> </ul>"},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes.DType","title":"DType","text":"<pre><code>DType(dtype_str: str)\n</code></pre> <p>A class to represent a data type in C/C++ and Cython/PYX files.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_c_decl</code>             \u2013              <p>Convert this dtype to the equivalent C/C++ declaration with the given name.</p> </li> <li> <code>to_pyxtype</code>             \u2013              <p>Convert this dtype to the equivalent PYX type.</p> </li> <li> <code>to_rvalue</code>             \u2013              <p>Convert this dtype into an r-value to be used in PYX files for assignments.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>base_c_type</code>               (<code>str</code>)           \u2013            <p>Convert the base of this DType into the equivalent C/C++ type.</p> </li> </ul> Source code in <code>src/spatial_graph/dtypes.py</code> <pre><code>def __init__(self, dtype_str: str) -&gt; None:\n    self.as_string = dtype_str\n    self.base, self.size = self.__parse_array_dtype(dtype_str)\n    self.is_array = self.size is not None\n    self.shape = (self.size,) if self.is_array else ()\n</code></pre>"},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes.DType(dtype_str)","title":"<code>dtype_str</code>","text":"(<code>str</code>)           \u2013            <p>The data type string in the format \"base_type[size]\". The base_type must be one of the valid base types defined in VALID_BASE_TYPES, and size is optional.</p>"},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes.DType.base_c_type","title":"base_c_type  <code>property</code>","text":"<pre><code>base_c_type: str\n</code></pre> <p>Convert the base of this DType into the equivalent C/C++ type.</p>"},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes.DType.to_c_decl","title":"to_c_decl","text":"<pre><code>to_c_decl(name: str) -&gt; str\n</code></pre> <p>Convert this dtype to the equivalent C/C++ declaration with the given name.</p> <p>\"base_c_type name\"        if not an array \"base_c_type name[size]\"  if an array type</p> Source code in <code>src/spatial_graph/dtypes.py</code> <pre><code>def to_c_decl(self, name: str) -&gt; str:\n    \"\"\"Convert this dtype to the equivalent C/C++ declaration with the given name.\n\n    \"base_c_type name\"        if not an array\n    \"base_c_type name[size]\"  if an array type\n    \"\"\"\n    if self.is_array:\n        return f\"{self.base_c_type} {name}[{self.size}]\"\n    else:\n        return f\"{self.base_c_type} {name}\"\n</code></pre>"},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes.DType.to_pyxtype","title":"to_pyxtype","text":"<pre><code>to_pyxtype(\n    use_memory_view: bool = False, add_dim: bool = False\n) -&gt; str\n</code></pre> <p>Convert this dtype to the equivalent PYX type.</p> <pre><code>\"base_c_type\"\n\"base_c_type[size]\"     if an array type\n\"base_c_type[::1]\"      if an array type and use_memory_view\n\"base_c_type[::1]\"      if not an array type and add_dim\n\"base_c_type[:, ::1]\"   if an array type and add_dim\n</code></pre> <p>Args:</p> <pre><code>use_memory_view:\n\n    If set, will produce \"dtype[::1]\" instead of \"dtype[dim]\" for\n    array types.\n\nadd_dim:\n\n    Append a dim to the type, e.g., \"int32_t[::1]\" instead of\n    \"int32_t\" for dtype \"int32\". If this DType is already an array,\n    will create a 2D array, e.g., \"int32_t[:, ::1]\".\n</code></pre> Source code in <code>src/spatial_graph/dtypes.py</code> <pre><code>def to_pyxtype(self, use_memory_view: bool = False, add_dim: bool = False) -&gt; str:\n    \"\"\"Convert this dtype to the equivalent PYX type.\n\n        \"base_c_type\"\n        \"base_c_type[size]\"     if an array type\n        \"base_c_type[::1]\"      if an array type and use_memory_view\n        \"base_c_type[::1]\"      if not an array type and add_dim\n        \"base_c_type[:, ::1]\"   if an array type and add_dim\n\n    Args:\n\n        use_memory_view:\n\n            If set, will produce \"dtype[::1]\" instead of \"dtype[dim]\" for\n            array types.\n\n        add_dim:\n\n            Append a dim to the type, e.g., \"int32_t[::1]\" instead of\n            \"int32_t\" for dtype \"int32\". If this DType is already an array,\n            will create a 2D array, e.g., \"int32_t[:, ::1]\".\n    \"\"\"\n    if self.is_array:\n        if add_dim:\n            suffix = \"[:, ::1]\"\n        else:\n            if use_memory_view:\n                suffix = \"[::1]\"\n            else:\n                suffix = f\"[{self.size}]\"\n    else:\n        suffix = \"[::1]\" if add_dim else \"\"\n\n    return self.base_c_type + suffix\n</code></pre>"},{"location":"reference/spatial_graph/dtypes/#spatial_graph.dtypes.DType.to_rvalue","title":"to_rvalue","text":"<pre><code>to_rvalue(name: str, array_index: str | None = None) -&gt; str\n</code></pre> <p>Convert this dtype into an r-value to be used in PYX files for assignments.</p> <p>\"name\"                  default \"name[array_index]\"     if array_index is given \"{name[0], ..., name[size-1]}\"                         if an array type \"{name[array_index, 0], ..., name[array_index, size-1]}\"                         if an array type and array_index is given</p> Source code in <code>src/spatial_graph/dtypes.py</code> <pre><code>def to_rvalue(self, name: str, array_index: str | None = None) -&gt; str:\n    \"\"\"Convert this dtype into an r-value to be used in PYX files for assignments.\n\n    \"name\"                  default\n    \"name[array_index]\"     if array_index is given\n    \"{name[0], ..., name[size-1]}\"\n                            if an array type\n    \"{name[array_index, 0], ..., name[array_index, size-1]}\"\n                            if an array type and array_index is given\n    \"\"\"\n\n    if self.size:\n        if array_index:\n            return (\n                \"{\"\n                + \", \".join(\n                    [f\"{name}[{array_index}, {i}]\" for i in range(self.size)]\n                )\n                + \"}\"\n            )\n        else:\n            return (\n                \"{\" + \", \".join([name + f\"[{i}]\" for i in range(self.size)]) + \"}\"\n            )\n    else:\n        if array_index:\n            return f\"{name}[{array_index}]\"\n        else:\n            return name\n</code></pre>"},{"location":"reference/spatial_graph/graph/","title":"spatial_graph.graph","text":""},{"location":"reference/spatial_graph/graph/#spatial_graph.graph","title":"spatial_graph.graph","text":"<p>Modules:</p> <ul> <li> <code>cgraph</code>           \u2013            <p>Stubs for classes generated by wrapper_template.pyx.</p> </li> <li> <code>graph</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>Base class for directed graph instances.</p> </li> <li> <code>Graph</code>           \u2013            <p>Base class for undirected graph instances.</p> </li> <li> <code>GraphBase</code>           \u2013            <p>Base class for compiled graph instances.</p> </li> </ul>"},{"location":"reference/spatial_graph/graph/#spatial_graph.graph.DiGraph","title":"DiGraph","text":"<pre><code>DiGraph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>GraphBase</code></p> <p>Base class for directed graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/graph/#spatial_graph.graph.Graph","title":"Graph","text":"<pre><code>Graph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>GraphBase</code></p> <p>Base class for undirected graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/graph/#spatial_graph.graph.GraphBase","title":"GraphBase","text":"<pre><code>GraphBase(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>Base class for compiled graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/graph/graph/","title":"spatial_graph.graph.graph","text":""},{"location":"reference/spatial_graph/graph/graph/#spatial_graph.graph.graph","title":"spatial_graph.graph.graph","text":"<p>Classes:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>Base class for directed graph instances.</p> </li> <li> <code>Graph</code>           \u2013            <p>Base class for undirected graph instances.</p> </li> <li> <code>GraphBase</code>           \u2013            <p>Base class for compiled graph instances.</p> </li> </ul>"},{"location":"reference/spatial_graph/graph/graph/#spatial_graph.graph.graph.DiGraph","title":"DiGraph","text":"<pre><code>DiGraph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>GraphBase</code></p> <p>Base class for directed graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/graph/graph/#spatial_graph.graph.graph.Graph","title":"Graph","text":"<pre><code>Graph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>GraphBase</code></p> <p>Base class for undirected graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/graph/graph/#spatial_graph.graph.graph.GraphBase","title":"GraphBase","text":"<pre><code>GraphBase(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>Base class for compiled graph instances.</p> Source code in <code>src/spatial_graph/graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/","title":"spatial_graph.rtree","text":""},{"location":"reference/spatial_graph/rtree/#spatial_graph.rtree","title":"spatial_graph.rtree","text":"<p>Modules:</p> <ul> <li> <code>line_rtree</code>           \u2013            </li> <li> <code>rtree</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>LineRTree</code>           \u2013            </li> </ul>"},{"location":"reference/spatial_graph/rtree/#spatial_graph.rtree.LineRTree","title":"LineRTree","text":"<pre><code>LineRTree(item_dtype, coord_dtype, dims)\n</code></pre> <p>               Bases: <code>RTree</code></p> <p>Methods:</p> <ul> <li> <code>insert_line</code>             \u2013              <p>Convenience function to insert a single line. To insert multiple</p> </li> <li> <code>insert_lines</code>             \u2013              <p>Insert a list of lines.</p> </li> </ul> Source code in <code>src/spatial_graph/rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype, coord_dtype, dims):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/#spatial_graph.rtree.LineRTree.insert_line","title":"insert_line","text":"<pre><code>insert_line(line, start, end)\n</code></pre> <p>Convenience function to insert a single line. To insert multiple lines in bulk, please use the faster <code>insert_lines</code>.</p> <p>Args:</p> <pre><code>line (`item_dtype`):\n\n    The line identifier (as passed as the `item_dtype` to the\n    constructor).\n\nstart (`ndarray`, shape `(d,)`):\n\n    The coordinates of the start of the line.\n\nend (`ndarray`, shape `(d,)`):\n\n    The coordinates of the end of the line.\n</code></pre> Source code in <code>src/spatial_graph/rtree/line_rtree.py</code> <pre><code>def insert_line(self, line, start, end):\n    \"\"\"Convenience function to insert a single line. To insert multiple\n    lines in bulk, please use the faster `insert_lines`.\n\n    Args:\n\n        line (`item_dtype`):\n\n            The line identifier (as passed as the `item_dtype` to the\n            constructor).\n\n        start (`ndarray`, shape `(d,)`):\n\n            The coordinates of the start of the line.\n\n        end (`ndarray`, shape `(d,)`):\n\n            The coordinates of the end of the line.\n    \"\"\"\n    lines = np.array([line], dtype=self.item_dtype.base)\n    starts = start[np.newaxis]\n    ends = end[np.newaxis]\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/#spatial_graph.rtree.LineRTree.insert_lines","title":"insert_lines","text":"<pre><code>insert_lines(lines, starts, ends)\n</code></pre> <p>Insert a list of lines.</p> <p>Args:</p> <pre><code>lines (`ndarray`, shape `(n, [m])`):\n\n    Array containing the line identifiers (as passed as the\n    `item_dtype` to the constructor). If the identifiers are an\n    array of size `m`, the expected shape is `(n, m)` where `n` is\n    the number of lines, otherwise the shape is just `(n,)`.\n\nstarts (`ndarray`, shape `(n, d)`):\n\n    The coordinates of the start of each line.\n\nends (`ndarray`, shape `(n, d)`):\n\n    The coordinates of the end of each line.\n</code></pre> Source code in <code>src/spatial_graph/rtree/line_rtree.py</code> <pre><code>def insert_lines(self, lines, starts, ends):\n    \"\"\"Insert a list of lines.\n\n    Args:\n\n        lines (`ndarray`, shape `(n, [m])`):\n\n            Array containing the line identifiers (as passed as the\n            `item_dtype` to the constructor). If the identifiers are an\n            array of size `m`, the expected shape is `(n, m)` where `n` is\n            the number of lines, otherwise the shape is just `(n,)`.\n\n        starts (`ndarray`, shape `(n, d)`):\n\n            The coordinates of the start of each line.\n\n        ends (`ndarray`, shape `(n, d)`):\n\n            The coordinates of the end of each line.\n    \"\"\"\n    # we just forward to bb insert, \"start\" and \"end\" will be used to compute\n    # the bounding box in our custom converter above\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/line_rtree/","title":"spatial_graph.rtree.line_rtree","text":""},{"location":"reference/spatial_graph/rtree/line_rtree/#spatial_graph.rtree.line_rtree","title":"spatial_graph.rtree.line_rtree","text":"<p>Classes:</p> <ul> <li> <code>LineRTree</code>           \u2013            </li> </ul>"},{"location":"reference/spatial_graph/rtree/line_rtree/#spatial_graph.rtree.line_rtree.LineRTree","title":"LineRTree","text":"<pre><code>LineRTree(item_dtype, coord_dtype, dims)\n</code></pre> <p>               Bases: <code>RTree</code></p> <p>Methods:</p> <ul> <li> <code>insert_line</code>             \u2013              <p>Convenience function to insert a single line. To insert multiple</p> </li> <li> <code>insert_lines</code>             \u2013              <p>Insert a list of lines.</p> </li> </ul> Source code in <code>src/spatial_graph/rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype, coord_dtype, dims):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/line_rtree/#spatial_graph.rtree.line_rtree.LineRTree.insert_line","title":"insert_line","text":"<pre><code>insert_line(line, start, end)\n</code></pre> <p>Convenience function to insert a single line. To insert multiple lines in bulk, please use the faster <code>insert_lines</code>.</p> <p>Args:</p> <pre><code>line (`item_dtype`):\n\n    The line identifier (as passed as the `item_dtype` to the\n    constructor).\n\nstart (`ndarray`, shape `(d,)`):\n\n    The coordinates of the start of the line.\n\nend (`ndarray`, shape `(d,)`):\n\n    The coordinates of the end of the line.\n</code></pre> Source code in <code>src/spatial_graph/rtree/line_rtree.py</code> <pre><code>def insert_line(self, line, start, end):\n    \"\"\"Convenience function to insert a single line. To insert multiple\n    lines in bulk, please use the faster `insert_lines`.\n\n    Args:\n\n        line (`item_dtype`):\n\n            The line identifier (as passed as the `item_dtype` to the\n            constructor).\n\n        start (`ndarray`, shape `(d,)`):\n\n            The coordinates of the start of the line.\n\n        end (`ndarray`, shape `(d,)`):\n\n            The coordinates of the end of the line.\n    \"\"\"\n    lines = np.array([line], dtype=self.item_dtype.base)\n    starts = start[np.newaxis]\n    ends = end[np.newaxis]\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/line_rtree/#spatial_graph.rtree.line_rtree.LineRTree.insert_lines","title":"insert_lines","text":"<pre><code>insert_lines(lines, starts, ends)\n</code></pre> <p>Insert a list of lines.</p> <p>Args:</p> <pre><code>lines (`ndarray`, shape `(n, [m])`):\n\n    Array containing the line identifiers (as passed as the\n    `item_dtype` to the constructor). If the identifiers are an\n    array of size `m`, the expected shape is `(n, m)` where `n` is\n    the number of lines, otherwise the shape is just `(n,)`.\n\nstarts (`ndarray`, shape `(n, d)`):\n\n    The coordinates of the start of each line.\n\nends (`ndarray`, shape `(n, d)`):\n\n    The coordinates of the end of each line.\n</code></pre> Source code in <code>src/spatial_graph/rtree/line_rtree.py</code> <pre><code>def insert_lines(self, lines, starts, ends):\n    \"\"\"Insert a list of lines.\n\n    Args:\n\n        lines (`ndarray`, shape `(n, [m])`):\n\n            Array containing the line identifiers (as passed as the\n            `item_dtype` to the constructor). If the identifiers are an\n            array of size `m`, the expected shape is `(n, m)` where `n` is\n            the number of lines, otherwise the shape is just `(n,)`.\n\n        starts (`ndarray`, shape `(n, d)`):\n\n            The coordinates of the start of each line.\n\n        ends (`ndarray`, shape `(n, d)`):\n\n            The coordinates of the end of each line.\n    \"\"\"\n    # we just forward to bb insert, \"start\" and \"end\" will be used to compute\n    # the bounding box in our custom converter above\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/point_rtree/","title":"spatial_graph.rtree.point_rtree","text":""},{"location":"reference/spatial_graph/rtree/point_rtree/#spatial_graph.rtree.point_rtree","title":"spatial_graph.rtree.point_rtree","text":""},{"location":"reference/spatial_graph/rtree/rtree/","title":"spatial_graph.rtree.rtree","text":""},{"location":"reference/spatial_graph/rtree/rtree/#spatial_graph.rtree.rtree","title":"spatial_graph.rtree.rtree","text":"<p>Classes:</p> <ul> <li> <code>RTree</code>           \u2013            <p>A generic RTree implementation, compiled on-the-fly during</p> </li> </ul>"},{"location":"reference/spatial_graph/rtree/rtree/#spatial_graph.rtree.rtree.RTree","title":"RTree","text":"<pre><code>RTree(item_dtype, coord_dtype, dims)\n</code></pre> <p>A generic RTree implementation, compiled on-the-fly during instantiation.</p> <p>Args:</p> <pre><code>item_dtype (``string``):\n\n    The C type of the items to hold. Can be a scalar (e.g. ``uint64``)\n    or an array of scalars (e.g., \"uint64[3]\").\n\ncoord_dtype (``string``):\n\n    The scalar C type to use for coordinates (e.g., ``float``).\n\ndims (``int``):\n\n    The dimension of the r-tree.\n</code></pre> <p>Subclassing:</p> <pre><code>This generic implementation can be subclassed and modified in the\nfollowing ways:\n\nThe class members ``pyx_item_t_declaration`` and\n``c_item_t_declaration`` can be overwritten to use custom ``item_t``\nstructures. This will also require overwriting the\n``c_converter_functions`` to translate between the PYX interface (where\nitems are scalars or C arrays of scalars) and the C interface (the\ncustom ``item_t`` type.\n\nThe following constants and typedefs are available to use in the\nprovided code:\n\n    DIMS:\n\n        A constant set to the value of ``dims``.\n\n    item_base_t:\n\n        The scalar type of the item (e.g., ``uint64``), regardless of\n        whether this is a scalar or array item.\n</code></pre> <p>insert_point_items():</p> <pre><code>Args:\n\n    items (ndarray):\n\n        Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n        array of `k` scalars per item).\n\n    points (ndarray):\n\n        Array of shape `(n, dims)`, the positions of the points to\n        insert.\n</code></pre> <p>insert_bb_items():</p> <pre><code>Args:\n\n    items (ndarray):\n\n        Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n        array of `k` scalars per item).\n\n    bb_mins/bb_maxs (ndarray):\n\n        Array of shape `(n, dims)`, the minimum/maximum points of the\n        bounding boxes per item to insert.\n</code></pre> <p>count():</p> <pre><code>Count the number of items in a bounding box.\n\nArgs:\n\n    bb_min/bb_max (ndarray):\n\n        Array of shape `(dims,)`, the minimum/maximum point of the\n        bounding box to count items in.\n</code></pre> <p>bounding_box():</p> <pre><code>Get the total bounding box of all items in this RTree.\n</code></pre> <p>search():</p> <pre><code>Get all items contained in a bounding box.\n\nArgs:\n\n    bb_min/bb_max (ndarray):\n\n        Array of shape `(dims,)`, the minimum/maximum point of the\n        bounding box to search items in.\n</code></pre> <p>nearest():</p> <pre><code>Get the nearest items to a given point.\n\nArgs:\n\n    point (ndarray):\n\n        The coordinates of the query point.\n\n    k (int):\n\n        The maximal number of items to return.\n\n    return_distances (bool):\n\n        If `True`, return a tuple of `(items, distances)`, where\n        `distances` contains the distance of each found item to the\n        query point.\n</code></pre> <p>delete_items():</p> <pre><code>Delete items by their content and bounding box. Only items that match\nboth the `items` row (a scalar or array, depending on `item_dtype`) and\nthe exact coordinates of their bounding box will be deleted.\n\nArgs:\n\n    items (ndarray):\n\n        Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n        array of `k` scalars per item).\n\n    bb_mins/bb_maxs (ndarray):\n\n        Array of shape `(n, dims)`, the minimum/maximum points of the\n        bounding boxes per item to delete. `bb_maxs` is optional for\n        point items, where min and max are the same.\n</code></pre> <p>len():</p> <pre><code>Get the number of items in this RTree.\n</code></pre> <p>Methods:</p> <ul> <li> <code>delete_item</code>             \u2013              <p>Delete a single item.</p> </li> <li> <code>insert_point_item</code>             \u2013              <p>Insert a single point item.</p> </li> </ul> Source code in <code>src/spatial_graph/rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype, coord_dtype, dims):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/rtree/#spatial_graph.rtree.rtree.RTree.delete_item","title":"delete_item","text":"<pre><code>delete_item(item, bb_min, bb_max=None)\n</code></pre> <p>Delete a single item.</p> <p>To delete multiple items, use <code>delete_items</code>.</p> Source code in <code>src/spatial_graph/rtree/rtree.py</code> <pre><code>def delete_item(self, item, bb_min, bb_max=None):\n    \"\"\"Delete a single item.\n\n    To delete multiple items, use `delete_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    bb_mins = bb_min[np.newaxis, :]\n    bb_maxs = None if bb_max is None else bb_max[np.newaxis, :]\n    return self.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/rtree/rtree/#spatial_graph.rtree.rtree.RTree.insert_point_item","title":"insert_point_item","text":"<pre><code>insert_point_item(item, position)\n</code></pre> <p>Insert a single point item.</p> <p>To insert multiple points, use <code>insert_point_items</code>.</p> Source code in <code>src/spatial_graph/rtree/rtree.py</code> <pre><code>def insert_point_item(self, item, position):\n    \"\"\"Insert a single point item.\n\n    To insert multiple points, use `insert_point_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    positions = position[np.newaxis]\n    return self.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/spatial_graph/","title":"spatial_graph.spatial_graph","text":""},{"location":"reference/spatial_graph/spatial_graph/#spatial_graph.spatial_graph","title":"spatial_graph.spatial_graph","text":"<p>Classes:</p> <ul> <li> <code>SpatialDiGraph</code>           \u2013            <p>Base class for directed spatial graph instances.</p> </li> <li> <code>SpatialGraph</code>           \u2013            <p>Base class for undirected spatial graph instances.</p> </li> </ul>"},{"location":"reference/spatial_graph/spatial_graph/#spatial_graph.spatial_graph.SpatialDiGraph","title":"SpatialDiGraph","text":"<pre><code>SpatialDiGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>SpatialGraphBase</code>, <code>DiGraph</code></p> <p>Base class for directed spatial graph instances.</p> Source code in <code>src/spatial_graph/spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/spatial_graph/#spatial_graph.spatial_graph.SpatialGraph","title":"SpatialGraph","text":"<pre><code>SpatialGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>SpatialGraphBase</code>, <code>Graph</code></p> <p>Base class for undirected spatial graph instances.</p> Source code in <code>src/spatial_graph/spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"}]}