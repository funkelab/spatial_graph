{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spatial-graph","text":"<p><code>spatial-graph</code> provides a data structure for directed and undirected graphs, where each node has an nD position (in time or space).</p> <p>It leverages well-in-time compiled C++ code for efficient graph operations, coupled with an rtree implementation for fast spatial queries.</p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Support for arbitrary number of dimensions</li> <li>Typed node identifiers and attributes<ul> <li>Any fixed-length type that is supported by <code>numpy</code></li> </ul> </li> <li>Efficient node/edge queries by<ul> <li>ROI</li> <li>kNN (by points / lines)</li> </ul> </li> <li>numpy-like interface for efficient:<ul> <li>Graph population and manipulation</li> <li>Query results</li> <li>Attribute access</li> </ul> </li> <li>Minimal memory footprint</li> <li>Minimal dependencies</li> <li>PYX API for graph algorithms in C/C++</li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Graph creation:</p> <pre><code>graph = sg.SpatialGraph(\n    ndims=3,\n    node_dtype=\"uint64\",\n    node_attr_dtypes={\"position\": \"double[3]\"},\n    edge_attr_dtypes={\"score\": \"float32\"},\n    position_attr=\"position\",\n)\n</code></pre> <p>Adding nodes/edges:</p> <pre><code>graph.add_nodes(\n    np.array([1, 2, 3, 4, 5], dtype=\"uint64\"),\n    position=np.array(\n        [\n            [0.1, 0.1, 0.1],\n            [0.2, 0.2, 0.2],\n            [0.3, 0.3, 0.3],\n            [0.4, 0.4, 0.4],\n            [0.5, 0.5, 0.5],\n        ],\n        dtype=\"double\",\n    ),\n)\n\ngraph.add_edges(\n    np.array([[1, 2], [3, 4], [5, 1]], dtype=\"uint64\"),\n    score=np.array([0.2, 0.3, 0.4], dtype=\"float32\"),\n)\n</code></pre> <p>Query nodes/edges in ROI:</p> <pre><code># nodes/edges will be numpy arrays of dtype uint64 and shape (n,)/(n, 2)\nnodes = graph.query_nodes_in_roi(np.array([[0.0, 0.0, 0.0], [0.25, 0.25, 0.25]]))\nedges = graph.query_edges_in_roi(np.array([[0.0, 0.0, 0.0], [0.25, 0.25, 0.25]]))\n</code></pre> <p>Query nodes/edges by position:</p> <pre><code>nodes = graph.query_nearest_nodes(np.array([0.3, 0.3, 0.3]), k=3)\nedges = graph.query_nearest_edges(np.array([0.3, 0.3, 0.3]), k=3)\n</code></pre> <p>Access node/edge attributes:</p> <pre><code>node_positions = graph.node_attrs[nodes].position\nedge_scores = graph.edge_attrs[edges].score\n</code></pre> <p>Delete nodes/edges:</p> <pre><code>graph.remove_nodes(nodes[:1000])\n</code></pre> <p>See the API documentation for more details.</p>"},{"location":"reference/spatial_graph/","title":"spatial_graph","text":""},{"location":"reference/spatial_graph/#spatial_graph","title":"spatial_graph","text":"<p>Classes:</p> <ul> <li> <code>DiGraph</code>           \u2013            </li> <li> <code>Graph</code>           \u2013            </li> <li> <code>GraphBase</code>           \u2013            </li> <li> <code>LineRTree</code>           \u2013            </li> <li> <code>PointRTree</code>           \u2013            </li> <li> <code>SpatialDiGraph</code>           \u2013            <p>Base class for directed spatial graph instances.</p> </li> <li> <code>SpatialGraph</code>           \u2013            <p>Base class for undirected spatial graph instances.</p> </li> <li> <code>SpatialGraphBase</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>create_graph</code>             \u2013              <p>Convenience factory function to create a graph instance.</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph","title":"DiGraph","text":"<pre><code>DiGraph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._graph.graph_base.GraphBase</code></p> <p>Methods:</p> <ul> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edges</code>             \u2013              <p>Add multiple edges to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a single node to the graph.</p> </li> <li> <code>add_nodes</code>             \u2013              <p>Add multiple nodes to the graph.</p> </li> <li> <code>edges_data</code>             \u2013              <p>Iterate over edge data for specified edges.</p> </li> <li> <code>in_edges</code>             \u2013              <p>Iterate over incoming edges to a node.</p> </li> <li> <code>in_edges_by_nodes</code>             \u2013              <p>Get all incoming edges to the specified nodes.</p> </li> <li> <code>nodes_data</code>             \u2013              <p>Iterate over nodes and their associated data.</p> </li> <li> <code>num_edges</code>             \u2013              <p>Get the total number of edges in the graph.</p> </li> <li> <code>num_in_neighbors</code>             \u2013              <p>Return the number of incoming neighbors for each node.</p> </li> <li> <code>num_out_neighbors</code>             \u2013              <p>Return the number of outgoing neighbors for each node.</p> </li> <li> <code>out_edges</code>             \u2013              <p>Iterate over outgoing edges from a node.</p> </li> <li> <code>out_edges_by_nodes</code>             \u2013              <p>Get all outgoing edges from the specified nodes.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a single node from the graph.</p> </li> <li> <code>remove_nodes</code>             \u2013              <p>Remove multiple nodes from the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>directed</code>           \u2013            <p>bool(x) -&gt; bool</p> </li> <li> <code>nodes</code>           \u2013            <p>Get all node IDs in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n\n    cgraph_cls = _compile_graph(\n        node_dtype=self.node_dtype,\n        node_attr_dtypes=self.node_attr_dtypes,\n        edge_attr_dtypes=self.edge_attr_dtypes,\n        directed=self.directed,\n    )\n    self._cgraph = cgraph_cls()\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.directed","title":"directed  <code>class</code>","text":"<pre><code>directed = True\n</code></pre> <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Get all node IDs in the graph.</p> <p>The returned array is a copy and modifications will not affect the graph structure.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing all node identifiers in the graph, ordered by insertion order (earliest added first).</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(edge: ndarray, *args: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>The edge attributes provided via args and *kwargs must match the data types and names specified in <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of edges added (1 if successful, 0 if edge already exists).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_edge(self, edge: np.ndarray, *args: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add an edge to the graph.\n\n    The edge attributes provided via *args and **kwargs must match the\n    data types and names specified in `edge_attr_dtypes` when the graph\n    was created.\n\n    Parameters\n    ----------\n    edge : np.ndarray\n        Array of length 2 containing [source_node, target_node].\n    *args : Any\n        Positional arguments for edge attributes. Names/number of args\n        must match the `edge_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for edge attributes. Names/number of kwargs\n        must match the `edge_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of edges added (1 if successful, 0 if edge already exists).\n    \"\"\"\n    return self._cgraph.add_edge(edge, *args, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edge(edge)","title":"<code>edge</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of length 2 containing [source_node, target_node].</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edge(*args)","title":"<code>*args</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for edge attributes. Names/number of args must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edge(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for edge attributes. Names/number of kwargs must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edges","title":"add_edges","text":"<pre><code>add_edges(\n    edges: ndarray, *args: ndarray, **kwargs: ndarray\n) -&gt; int\n</code></pre> <p>Add multiple edges to the graph.</p> <p>Edge attributes provided via args and *kwargs must match the data types and names specified in <code>edge_attr_dtypes</code>. Each attribute array must have the same length as the number of edges.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of edges successfully added.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_edges(\n    self, edges: np.ndarray, *args: np.ndarray, **kwargs: np.ndarray\n) -&gt; int:\n    \"\"\"Add multiple edges to the graph.\n\n    Edge attributes provided via *args and **kwargs must match the\n    data types and names specified in `edge_attr_dtypes`. Each attribute\n    array must have the same length as the number of edges.\n\n    Parameters\n    ----------\n    edges : np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node].\n    *args : np.ndarray\n        Positional arguments for edge attributes. Each argument should be\n        an array with length matching the number of edges. Names/number\n        of args must match the `edge_attr_dtypes`.\n    **kwargs : np.ndarray\n        Keyword arguments for edge attributes. Each argument should be\n        an array with length matching the number of edges. Names/number\n        of kwargs must match the `edge_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of edges successfully added.\n    \"\"\"\n    return self._cgraph.add_edges(edges, *args, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edges(edges)","title":"<code>edges</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node].</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edges(*args)","title":"<code>*args</code>","text":"(<code>ndarray</code>)           \u2013            <p>Positional arguments for edge attributes. Each argument should be an array with length matching the number of edges. Names/number of args must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_edges(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Keyword arguments for edge attributes. Each argument should be an array with length matching the number of edges. Names/number of kwargs must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_node","title":"add_node","text":"<pre><code>add_node(node: Any, *data: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add a single node to the graph.</p> <p>The node attributes provided via data and *kwargs must match the data types and names specified in <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of nodes added (1 if successful, 0 if node already exists).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_node(self, node: Any, *data: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add a single node to the graph.\n\n    The node attributes provided via *data and **kwargs must match the\n    data types and names specified in `node_attr_dtypes` when the graph\n    was created.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to add to the graph.\n    *data : Any\n        Positional arguments for node attributes. Names/number of args\n        must match the `node_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for node attributes. Names/number of kwargs\n        must match the `node_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of nodes added (1 if successful, 0 if node already exists).\n    \"\"\"\n    return self._cgraph.add_node(node, *data, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to add to the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_node(*data)","title":"<code>*data</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for node attributes. Names/number of args must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_node(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for node attributes. Names/number of kwargs must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(nodes: ndarray, *data: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add multiple nodes to the graph.</p> <p>Node attributes provided via data and *kwargs must match the data types and names specified in <code>node_attr_dtypes</code>. Each attribute array must have the same length as the <code>nodes</code> array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of nodes successfully added.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_nodes(self, nodes: np.ndarray, *data: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add multiple nodes to the graph.\n\n    Node attributes provided via *data and **kwargs must match the\n    data types and names specified in `node_attr_dtypes`. Each attribute\n    array must have the same length as the `nodes` array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to add to the graph.\n    *data : Any\n        Positional arguments for node attributes. Each argument should be\n        an array with length matching `nodes`. Names/number of args must\n        match the `node_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for node attributes. Each argument should be\n        an array with length matching `nodes`. Names/number of kwargs\n        must match the `node_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of nodes successfully added.\n    \"\"\"\n    return self._cgraph.add_nodes(nodes, *data, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to add to the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_nodes(*data)","title":"<code>*data</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for node attributes. Each argument should be an array with length matching <code>nodes</code>. Names/number of args must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.add_nodes(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for node attributes. Each argument should be an array with length matching <code>nodes</code>. Names/number of kwargs must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.edges_data","title":"edges_data","text":"<pre><code>edges_data(us: ndarray, vs: ndarray) -&gt; Iterator\n</code></pre> <p>Iterate over edge data for specified edges.</p> <p>The arrays <code>us</code> and <code>vs</code> must have the same length. The edge data objects provide access to edge attributes as defined by the <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Any</code>           \u2013            <p>Edge data view objects providing access to edge attributes for each edge (us[i], vs[i]).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def edges_data(self, us: np.ndarray, vs: np.ndarray) -&gt; Iterator:\n    \"\"\"Iterate over edge data for specified edges.\n\n    The arrays `us` and `vs` must have the same length. The edge data\n    objects provide access to edge attributes as defined by the\n    `edge_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    us : np.ndarray\n        Array of source node identifiers.\n    vs : np.ndarray\n        Array of target node identifiers.\n\n    Yields\n    ------\n    Any\n        Edge data view objects providing access to edge attributes\n        for each edge (us[i], vs[i]).\n    \"\"\"\n    return self._cgraph.edges_data(us, vs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.edges_data(us)","title":"<code>us</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of source node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.edges_data(vs)","title":"<code>vs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of target node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.in_edges","title":"in_edges","text":"<pre><code>in_edges(\n    node: Any = None, data: bool = False\n) -&gt; Iterator[tuple]\n</code></pre> <p>Iterate over incoming edges to a node.</p> <p>Only edges directed toward the specified node are yielded.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple or tuple[tuple, Any]</code>           \u2013            <p>If <code>data=False</code>: tuples of (source_node, target_node) representing incoming edges where target_node is the specified node. If <code>data=True</code>: tuples of ((source_node, target_node), edge_data) where edge_data provides access to edge attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def in_edges(self, node: Any = None, data: bool = False) -&gt; Iterator[tuple]:\n    \"\"\"Iterate over incoming edges to a node.\n\n    Only edges directed toward the specified node are yielded.\n\n    Parameters\n    ----------\n    node : Any\n        The target node to find incoming edges for.\n    data : bool\n        If True, yield (edge, edge_data) tuples. If False, yield\n        only edge tuples.\n\n    Yields\n    ------\n    tuple or tuple[tuple, Any]\n        If `data=False`: tuples of (source_node, target_node) representing\n        incoming edges where target_node is the specified node.\n        If `data=True`: tuples of ((source_node, target_node), edge_data)\n        where edge_data provides access to edge attributes.\n    \"\"\"\n    return self._cgraph.in_edges(node, data)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.in_edges(node)","title":"<code>node</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The target node to find incoming edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.in_edges(data)","title":"<code>data</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, yield (edge, edge_data) tuples. If False, yield only edge tuples.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.in_edges_by_nodes","title":"in_edges_by_nodes","text":"<pre><code>in_edges_by_nodes(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Get all incoming edges to the specified nodes.</p> <p>This method provides fast access to incoming edges for an array of nodes. Edges between nodes in the input array will be reported multiple times if both source and target are in the array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node] representing an incoming edge to one of the specified nodes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def in_edges_by_nodes(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get all incoming edges to the specified nodes.\n\n    This method provides fast access to incoming edges for an array\n    of nodes. Edges between nodes in the input array will be reported\n    multiple times if both source and target are in the array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to find incoming edges for.\n\n    Returns\n    -------\n    np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node] representing an incoming edge\n        to one of the specified nodes.\n    \"\"\"\n    return self._cgraph.in_edges_by_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.in_edges_by_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to find incoming edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.nodes_data","title":"nodes_data","text":"<pre><code>nodes_data(\n    nodes: ndarray | None = None,\n) -&gt; Iterator[tuple[Any, Any]]\n</code></pre> <p>Iterate over nodes and their associated data.</p> <p>The node_data object provides access to node attributes as defined by the <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[Any, Any]</code>           \u2013            <p>Tuples of (node_id, node_data) where node_data is a view object providing access to the node's attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def nodes_data(self, nodes: np.ndarray | None = None) -&gt; Iterator[tuple[Any, Any]]:\n    \"\"\"Iterate over nodes and their associated data.\n\n    The node_data object provides access to node attributes as defined\n    by the `node_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    nodes : np.ndarray, optional\n        Array of specific node identifiers to iterate over. If None,\n        iterates over all nodes in the graph.\n\n    Yields\n    ------\n    tuple[Any, Any]\n        Tuples of (node_id, node_data) where node_data is a view object\n        providing access to the node's attributes.\n    \"\"\"\n    return self._cgraph.nodes_data(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.nodes_data(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of specific node identifiers to iterate over. If None, iterates over all nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.num_edges","title":"num_edges","text":"<pre><code>num_edges() -&gt; int\n</code></pre> <p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def num_edges(self) -&gt; int:\n    \"\"\"Get the total number of edges in the graph.\n\n    Returns\n    -------\n    int\n        The number of edges in the graph.\n    \"\"\"\n    return self._cgraph.num_edges()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.num_in_neighbors","title":"num_in_neighbors","text":"<pre><code>num_in_neighbors(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Return the number of incoming neighbors for each node.</p> <p>This counts only nodes that have edges pointing to the specified nodes (i.e., predecessors).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of incoming neighbor counts for each node in the input array.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def num_in_neighbors(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the number of incoming neighbors for each node.\n\n    This counts only nodes that have edges pointing to the specified nodes\n    (i.e., predecessors).\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to count incoming neighbors for.\n\n    Returns\n    -------\n    np.ndarray\n        Array of incoming neighbor counts for each node in the input array.\n    \"\"\"\n    return self._cgraph.num_in_neighbors(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.num_in_neighbors(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to count incoming neighbors for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.num_out_neighbors","title":"num_out_neighbors","text":"<pre><code>num_out_neighbors(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Return the number of outgoing neighbors for each node.</p> <p>This counts only nodes that the specified nodes have edges pointing to (i.e., successors).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of outgoing neighbor counts for each node in the input array.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def num_out_neighbors(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the number of outgoing neighbors for each node.\n\n    This counts only nodes that the specified nodes\n    have edges pointing to (i.e., successors).\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to count outgoing neighbors for.\n\n    Returns\n    -------\n    np.ndarray\n        Array of outgoing neighbor counts for each node in the input array.\n    \"\"\"\n    return self._cgraph.num_out_neighbors(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.num_out_neighbors(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to count outgoing neighbors for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.out_edges","title":"out_edges","text":"<pre><code>out_edges(\n    node: Any = None, data: bool = False\n) -&gt; Iterator[tuple]\n</code></pre> <p>Iterate over outgoing edges from a node.</p> <p>Only edges directed away from the specified node are yielded.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple or tuple[tuple, Any]</code>           \u2013            <p>If <code>data=False</code>: tuples of (source_node, target_node) representing outgoing edges where source_node is the specified node. If <code>data=True</code>: tuples of ((source_node, target_node), edge_data) where edge_data provides access to edge attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def out_edges(self, node: Any = None, data: bool = False) -&gt; Iterator[tuple]:\n    \"\"\"Iterate over outgoing edges from a node.\n\n    Only edges directed away from the specified node are yielded.\n\n    Parameters\n    ----------\n    node : Any\n        The source node to find outgoing edges for.\n    data : bool\n        If True, yield (edge, edge_data) tuples. If False, yield\n        only edge tuples.\n\n    Yields\n    ------\n    tuple or tuple[tuple, Any]\n        If `data=False`: tuples of (source_node, target_node) representing\n        outgoing edges where source_node is the specified node.\n        If `data=True`: tuples of ((source_node, target_node), edge_data)\n        where edge_data provides access to edge attributes.\n    \"\"\"\n    return self._cgraph.out_edges(node, data)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.out_edges(node)","title":"<code>node</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The source node to find outgoing edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.out_edges(data)","title":"<code>data</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, yield (edge, edge_data) tuples. If False, yield only edge tuples.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.out_edges_by_nodes","title":"out_edges_by_nodes","text":"<pre><code>out_edges_by_nodes(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Get all outgoing edges from the specified nodes.</p> <p>This method provides fast access to outgoing edges for an array of nodes. Edges between nodes in the input array will be reported multiple times if both source and target are in the array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node] representing an outgoing edge from one of the specified nodes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def out_edges_by_nodes(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get all outgoing edges from the specified nodes.\n\n    This method provides fast access to outgoing edges for an array\n    of nodes. Edges between nodes in the input array will be reported\n    multiple times if both source and target are in the array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to find outgoing edges for.\n\n    Returns\n    -------\n    np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node] representing an outgoing edge\n        from one of the specified nodes.\n    \"\"\"\n    return self._cgraph.out_edges_by_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.out_edges_by_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to find outgoing edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: Any) -&gt; None\n</code></pre> <p>Remove a single node from the graph.</p> <p>Removing a node will also remove all edges incident to that node.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Remove a single node from the graph.\n\n    Removing a node will also remove all edges incident to that node.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_node(node)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.remove_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.remove_nodes","title":"remove_nodes","text":"<pre><code>remove_nodes(nodes: ndarray) -&gt; None\n</code></pre> <p>Remove multiple nodes from the graph.</p> <p>Removing nodes will also remove all edges incident to those nodes.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_nodes(self, nodes: np.ndarray) -&gt; None:\n    \"\"\"Remove multiple nodes from the graph.\n\n    Removing nodes will also remove all edges incident to those nodes.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph.remove_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph","title":"Graph","text":"<pre><code>Graph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._graph.graph_base.GraphBase</code></p> <p>Methods:</p> <ul> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edges</code>             \u2013              <p>Add multiple edges to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a single node to the graph.</p> </li> <li> <code>add_nodes</code>             \u2013              <p>Add multiple nodes to the graph.</p> </li> <li> <code>edges</code>             \u2013              <p>Iterate over edges in the graph.</p> </li> <li> <code>edges_by_nodes</code>             \u2013              <p>Get all edges incident to the specified nodes.</p> </li> <li> <code>edges_data</code>             \u2013              <p>Iterate over edge data for specified edges.</p> </li> <li> <code>nodes_data</code>             \u2013              <p>Iterate over nodes and their associated data.</p> </li> <li> <code>num_edges</code>             \u2013              <p>Get the total number of edges in the graph.</p> </li> <li> <code>num_neighbors</code>             \u2013              <p>Return the number of neighbors for each node.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a single node from the graph.</p> </li> <li> <code>remove_nodes</code>             \u2013              <p>Remove multiple nodes from the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>directed</code>           \u2013            <p>bool(x) -&gt; bool</p> </li> <li> <code>nodes</code>           \u2013            <p>Get all node IDs in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n\n    cgraph_cls = _compile_graph(\n        node_dtype=self.node_dtype,\n        node_attr_dtypes=self.node_attr_dtypes,\n        edge_attr_dtypes=self.edge_attr_dtypes,\n        directed=self.directed,\n    )\n    self._cgraph = cgraph_cls()\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.directed","title":"directed  <code>class</code>","text":"<pre><code>directed = False\n</code></pre> <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Get all node IDs in the graph.</p> <p>The returned array is a copy and modifications will not affect the graph structure.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing all node identifiers in the graph, ordered by insertion order (earliest added first).</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edge","title":"add_edge","text":"<pre><code>add_edge(edge: ndarray, *args: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>The edge attributes provided via args and *kwargs must match the data types and names specified in <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of edges added (1 if successful, 0 if edge already exists).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_edge(self, edge: np.ndarray, *args: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add an edge to the graph.\n\n    The edge attributes provided via *args and **kwargs must match the\n    data types and names specified in `edge_attr_dtypes` when the graph\n    was created.\n\n    Parameters\n    ----------\n    edge : np.ndarray\n        Array of length 2 containing [source_node, target_node].\n    *args : Any\n        Positional arguments for edge attributes. Names/number of args\n        must match the `edge_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for edge attributes. Names/number of kwargs\n        must match the `edge_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of edges added (1 if successful, 0 if edge already exists).\n    \"\"\"\n    return self._cgraph.add_edge(edge, *args, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edge(edge)","title":"<code>edge</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of length 2 containing [source_node, target_node].</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edge(*args)","title":"<code>*args</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for edge attributes. Names/number of args must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edge(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for edge attributes. Names/number of kwargs must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edges","title":"add_edges","text":"<pre><code>add_edges(\n    edges: ndarray, *args: ndarray, **kwargs: ndarray\n) -&gt; int\n</code></pre> <p>Add multiple edges to the graph.</p> <p>Edge attributes provided via args and *kwargs must match the data types and names specified in <code>edge_attr_dtypes</code>. Each attribute array must have the same length as the number of edges.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of edges successfully added.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_edges(\n    self, edges: np.ndarray, *args: np.ndarray, **kwargs: np.ndarray\n) -&gt; int:\n    \"\"\"Add multiple edges to the graph.\n\n    Edge attributes provided via *args and **kwargs must match the\n    data types and names specified in `edge_attr_dtypes`. Each attribute\n    array must have the same length as the number of edges.\n\n    Parameters\n    ----------\n    edges : np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node].\n    *args : np.ndarray\n        Positional arguments for edge attributes. Each argument should be\n        an array with length matching the number of edges. Names/number\n        of args must match the `edge_attr_dtypes`.\n    **kwargs : np.ndarray\n        Keyword arguments for edge attributes. Each argument should be\n        an array with length matching the number of edges. Names/number\n        of kwargs must match the `edge_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of edges successfully added.\n    \"\"\"\n    return self._cgraph.add_edges(edges, *args, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edges(edges)","title":"<code>edges</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node].</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edges(*args)","title":"<code>*args</code>","text":"(<code>ndarray</code>)           \u2013            <p>Positional arguments for edge attributes. Each argument should be an array with length matching the number of edges. Names/number of args must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_edges(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Keyword arguments for edge attributes. Each argument should be an array with length matching the number of edges. Names/number of kwargs must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_node","title":"add_node","text":"<pre><code>add_node(node: Any, *data: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add a single node to the graph.</p> <p>The node attributes provided via data and *kwargs must match the data types and names specified in <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of nodes added (1 if successful, 0 if node already exists).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_node(self, node: Any, *data: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add a single node to the graph.\n\n    The node attributes provided via *data and **kwargs must match the\n    data types and names specified in `node_attr_dtypes` when the graph\n    was created.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to add to the graph.\n    *data : Any\n        Positional arguments for node attributes. Names/number of args\n        must match the `node_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for node attributes. Names/number of kwargs\n        must match the `node_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of nodes added (1 if successful, 0 if node already exists).\n    \"\"\"\n    return self._cgraph.add_node(node, *data, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to add to the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_node(*data)","title":"<code>*data</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for node attributes. Names/number of args must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_node(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for node attributes. Names/number of kwargs must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(nodes: ndarray, *data: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add multiple nodes to the graph.</p> <p>Node attributes provided via data and *kwargs must match the data types and names specified in <code>node_attr_dtypes</code>. Each attribute array must have the same length as the <code>nodes</code> array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of nodes successfully added.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_nodes(self, nodes: np.ndarray, *data: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add multiple nodes to the graph.\n\n    Node attributes provided via *data and **kwargs must match the\n    data types and names specified in `node_attr_dtypes`. Each attribute\n    array must have the same length as the `nodes` array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to add to the graph.\n    *data : Any\n        Positional arguments for node attributes. Each argument should be\n        an array with length matching `nodes`. Names/number of args must\n        match the `node_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for node attributes. Each argument should be\n        an array with length matching `nodes`. Names/number of kwargs\n        must match the `node_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of nodes successfully added.\n    \"\"\"\n    return self._cgraph.add_nodes(nodes, *data, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to add to the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_nodes(*data)","title":"<code>*data</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for node attributes. Each argument should be an array with length matching <code>nodes</code>. Names/number of args must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.add_nodes(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for node attributes. Each argument should be an array with length matching <code>nodes</code>. Names/number of kwargs must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges","title":"edges","text":"<pre><code>edges(\n    node: Any = None, data: bool = False\n) -&gt; Iterator[tuple]\n</code></pre> <p>Iterate over edges in the graph.</p> <p>For undirected graphs, each edge is yielded only once with nodes ordered such that node1 &lt; node2 to avoid duplicates.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple or tuple[tuple, Any]</code>           \u2013            <p>If <code>data=False</code>: tuples of (node1, node2) representing edges. If <code>data=True</code>: tuples of ((node1, node2), edge_data) where edge_data provides access to edge attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def edges(self, node: Any = None, data: bool = False) -&gt; Iterator[tuple]:\n    \"\"\"Iterate over edges in the graph.\n\n    For undirected graphs, each edge is yielded only once with nodes\n    ordered such that node1 &lt; node2 to avoid duplicates.\n\n    Parameters\n    ----------\n    node : Any, optional\n        If provided, only iterate over edges incident to this node.\n        If None, iterate over all edges in the graph.\n    data : bool, default False\n        If True, yield (edge, edge_data) tuples. If False, yield\n        only edge tuples.\n\n    Yields\n    ------\n    tuple or tuple[tuple, Any]\n        If `data=False`: tuples of (node1, node2) representing edges.\n        If `data=True`: tuples of ((node1, node2), edge_data) where\n        edge_data provides access to edge attributes.\n    \"\"\"\n    return self._cgraph.edges(node, data)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges(node)","title":"<code>node</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only iterate over edges incident to this node. If None, iterate over all edges in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges(data)","title":"<code>data</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, yield (edge, edge_data) tuples. If False, yield only edge tuples.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges_by_nodes","title":"edges_by_nodes","text":"<pre><code>edges_by_nodes(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Get all edges incident to the specified nodes.</p> <p>This method provides fast access to edges incident to an array of nodes. Note that edges between nodes in the input array will be reported multiple times (once for each incident node).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [node1, node2] representing an edge. For undirected graphs, node1 &lt;= node2.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def edges_by_nodes(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get all edges incident to the specified nodes.\n\n    This method provides fast access to edges incident to an array\n    of nodes. Note that edges between nodes in the input array will\n    be reported multiple times (once for each incident node).\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to find incident edges for.\n\n    Returns\n    -------\n    np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [node1, node2] representing an edge. For undirected graphs,\n        node1 &lt;= node2.\n    \"\"\"\n    return self._cgraph.edges_by_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges_by_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to find incident edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges_data","title":"edges_data","text":"<pre><code>edges_data(us: ndarray, vs: ndarray) -&gt; Iterator\n</code></pre> <p>Iterate over edge data for specified edges.</p> <p>The arrays <code>us</code> and <code>vs</code> must have the same length. The edge data objects provide access to edge attributes as defined by the <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Any</code>           \u2013            <p>Edge data view objects providing access to edge attributes for each edge (us[i], vs[i]).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def edges_data(self, us: np.ndarray, vs: np.ndarray) -&gt; Iterator:\n    \"\"\"Iterate over edge data for specified edges.\n\n    The arrays `us` and `vs` must have the same length. The edge data\n    objects provide access to edge attributes as defined by the\n    `edge_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    us : np.ndarray\n        Array of source node identifiers.\n    vs : np.ndarray\n        Array of target node identifiers.\n\n    Yields\n    ------\n    Any\n        Edge data view objects providing access to edge attributes\n        for each edge (us[i], vs[i]).\n    \"\"\"\n    return self._cgraph.edges_data(us, vs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges_data(us)","title":"<code>us</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of source node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.edges_data(vs)","title":"<code>vs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of target node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.nodes_data","title":"nodes_data","text":"<pre><code>nodes_data(\n    nodes: ndarray | None = None,\n) -&gt; Iterator[tuple[Any, Any]]\n</code></pre> <p>Iterate over nodes and their associated data.</p> <p>The node_data object provides access to node attributes as defined by the <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[Any, Any]</code>           \u2013            <p>Tuples of (node_id, node_data) where node_data is a view object providing access to the node's attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def nodes_data(self, nodes: np.ndarray | None = None) -&gt; Iterator[tuple[Any, Any]]:\n    \"\"\"Iterate over nodes and their associated data.\n\n    The node_data object provides access to node attributes as defined\n    by the `node_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    nodes : np.ndarray, optional\n        Array of specific node identifiers to iterate over. If None,\n        iterates over all nodes in the graph.\n\n    Yields\n    ------\n    tuple[Any, Any]\n        Tuples of (node_id, node_data) where node_data is a view object\n        providing access to the node's attributes.\n    \"\"\"\n    return self._cgraph.nodes_data(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.nodes_data(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of specific node identifiers to iterate over. If None, iterates over all nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.num_edges","title":"num_edges","text":"<pre><code>num_edges() -&gt; int\n</code></pre> <p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def num_edges(self) -&gt; int:\n    \"\"\"Get the total number of edges in the graph.\n\n    Returns\n    -------\n    int\n        The number of edges in the graph.\n    \"\"\"\n    return self._cgraph.num_edges()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.num_neighbors","title":"num_neighbors","text":"<pre><code>num_neighbors(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Return the number of neighbors for each node.</p> <p>For undirected graphs, this counts all adjacent nodes regardless of edge direction since edges are bidirectional.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of neighbor counts for each node in the input array.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def num_neighbors(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the number of neighbors for each node.\n\n    For undirected graphs, this counts all adjacent nodes regardless\n    of edge direction since edges are bidirectional.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to count neighbors for.\n\n    Returns\n    -------\n    np.ndarray\n        Array of neighbor counts for each node in the input array.\n    \"\"\"\n    return self._cgraph.num_neighbors(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.num_neighbors(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to count neighbors for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: Any) -&gt; None\n</code></pre> <p>Remove a single node from the graph.</p> <p>Removing a node will also remove all edges incident to that node.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Remove a single node from the graph.\n\n    Removing a node will also remove all edges incident to that node.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_node(node)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.remove_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.remove_nodes","title":"remove_nodes","text":"<pre><code>remove_nodes(nodes: ndarray) -&gt; None\n</code></pre> <p>Remove multiple nodes from the graph.</p> <p>Removing nodes will also remove all edges incident to those nodes.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_nodes(self, nodes: np.ndarray) -&gt; None:\n    \"\"\"Remove multiple nodes from the graph.\n\n    Removing nodes will also remove all edges incident to those nodes.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph.remove_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase","title":"GraphBase","text":"<pre><code>GraphBase(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edges</code>             \u2013              <p>Add multiple edges to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a single node to the graph.</p> </li> <li> <code>add_nodes</code>             \u2013              <p>Add multiple nodes to the graph.</p> </li> <li> <code>edges_data</code>             \u2013              <p>Iterate over edge data for specified edges.</p> </li> <li> <code>nodes_data</code>             \u2013              <p>Iterate over nodes and their associated data.</p> </li> <li> <code>num_edges</code>             \u2013              <p>Get the total number of edges in the graph.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a single node from the graph.</p> </li> <li> <code>remove_nodes</code>             \u2013              <p>Remove multiple nodes from the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>directed</code>           \u2013            <p>bool(x) -&gt; bool</p> </li> <li> <code>nodes</code>           \u2013            <p>Get all node IDs in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n\n    cgraph_cls = _compile_graph(\n        node_dtype=self.node_dtype,\n        node_attr_dtypes=self.node_attr_dtypes,\n        edge_attr_dtypes=self.edge_attr_dtypes,\n        directed=self.directed,\n    )\n    self._cgraph = cgraph_cls()\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.directed","title":"directed  <code>class</code>","text":"<pre><code>directed = False\n</code></pre> <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Get all node IDs in the graph.</p> <p>The returned array is a copy and modifications will not affect the graph structure.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing all node identifiers in the graph, ordered by insertion order (earliest added first).</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edge","title":"add_edge","text":"<pre><code>add_edge(edge: ndarray, *args: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>The edge attributes provided via args and *kwargs must match the data types and names specified in <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of edges added (1 if successful, 0 if edge already exists).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_edge(self, edge: np.ndarray, *args: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add an edge to the graph.\n\n    The edge attributes provided via *args and **kwargs must match the\n    data types and names specified in `edge_attr_dtypes` when the graph\n    was created.\n\n    Parameters\n    ----------\n    edge : np.ndarray\n        Array of length 2 containing [source_node, target_node].\n    *args : Any\n        Positional arguments for edge attributes. Names/number of args\n        must match the `edge_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for edge attributes. Names/number of kwargs\n        must match the `edge_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of edges added (1 if successful, 0 if edge already exists).\n    \"\"\"\n    return self._cgraph.add_edge(edge, *args, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edge(edge)","title":"<code>edge</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of length 2 containing [source_node, target_node].</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edge(*args)","title":"<code>*args</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for edge attributes. Names/number of args must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edge(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for edge attributes. Names/number of kwargs must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edges","title":"add_edges","text":"<pre><code>add_edges(\n    edges: ndarray, *args: ndarray, **kwargs: ndarray\n) -&gt; int\n</code></pre> <p>Add multiple edges to the graph.</p> <p>Edge attributes provided via args and *kwargs must match the data types and names specified in <code>edge_attr_dtypes</code>. Each attribute array must have the same length as the number of edges.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of edges successfully added.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_edges(\n    self, edges: np.ndarray, *args: np.ndarray, **kwargs: np.ndarray\n) -&gt; int:\n    \"\"\"Add multiple edges to the graph.\n\n    Edge attributes provided via *args and **kwargs must match the\n    data types and names specified in `edge_attr_dtypes`. Each attribute\n    array must have the same length as the number of edges.\n\n    Parameters\n    ----------\n    edges : np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node].\n    *args : np.ndarray\n        Positional arguments for edge attributes. Each argument should be\n        an array with length matching the number of edges. Names/number\n        of args must match the `edge_attr_dtypes`.\n    **kwargs : np.ndarray\n        Keyword arguments for edge attributes. Each argument should be\n        an array with length matching the number of edges. Names/number\n        of kwargs must match the `edge_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of edges successfully added.\n    \"\"\"\n    return self._cgraph.add_edges(edges, *args, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edges(edges)","title":"<code>edges</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node].</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edges(*args)","title":"<code>*args</code>","text":"(<code>ndarray</code>)           \u2013            <p>Positional arguments for edge attributes. Each argument should be an array with length matching the number of edges. Names/number of args must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_edges(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Keyword arguments for edge attributes. Each argument should be an array with length matching the number of edges. Names/number of kwargs must match the <code>edge_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_node","title":"add_node","text":"<pre><code>add_node(node: Any, *data: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add a single node to the graph.</p> <p>The node attributes provided via data and *kwargs must match the data types and names specified in <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of nodes added (1 if successful, 0 if node already exists).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_node(self, node: Any, *data: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add a single node to the graph.\n\n    The node attributes provided via *data and **kwargs must match the\n    data types and names specified in `node_attr_dtypes` when the graph\n    was created.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to add to the graph.\n    *data : Any\n        Positional arguments for node attributes. Names/number of args\n        must match the `node_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for node attributes. Names/number of kwargs\n        must match the `node_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of nodes added (1 if successful, 0 if node already exists).\n    \"\"\"\n    return self._cgraph.add_node(node, *data, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to add to the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_node(*data)","title":"<code>*data</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for node attributes. Names/number of args must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_node(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for node attributes. Names/number of kwargs must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(nodes: ndarray, *data: Any, **kwargs: Any) -&gt; int\n</code></pre> <p>Add multiple nodes to the graph.</p> <p>Node attributes provided via data and *kwargs must match the data types and names specified in <code>node_attr_dtypes</code>. Each attribute array must have the same length as the <code>nodes</code> array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of nodes successfully added.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def add_nodes(self, nodes: np.ndarray, *data: Any, **kwargs: Any) -&gt; int:\n    \"\"\"Add multiple nodes to the graph.\n\n    Node attributes provided via *data and **kwargs must match the\n    data types and names specified in `node_attr_dtypes`. Each attribute\n    array must have the same length as the `nodes` array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to add to the graph.\n    *data : Any\n        Positional arguments for node attributes. Each argument should be\n        an array with length matching `nodes`. Names/number of args must\n        match the `node_attr_dtypes`.\n    **kwargs : Any\n        Keyword arguments for node attributes. Each argument should be\n        an array with length matching `nodes`. Names/number of kwargs\n        must match the `node_attr_dtypes`.\n\n    Returns\n    -------\n    int\n        Number of nodes successfully added.\n    \"\"\"\n    return self._cgraph.add_nodes(nodes, *data, **kwargs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to add to the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_nodes(*data)","title":"<code>*data</code>","text":"(<code>Any</code>)           \u2013            <p>Positional arguments for node attributes. Each argument should be an array with length matching <code>nodes</code>. Names/number of args must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.add_nodes(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>)           \u2013            <p>Keyword arguments for node attributes. Each argument should be an array with length matching <code>nodes</code>. Names/number of kwargs must match the <code>node_attr_dtypes</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.edges_data","title":"edges_data","text":"<pre><code>edges_data(us: ndarray, vs: ndarray) -&gt; Iterator\n</code></pre> <p>Iterate over edge data for specified edges.</p> <p>The arrays <code>us</code> and <code>vs</code> must have the same length. The edge data objects provide access to edge attributes as defined by the <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Any</code>           \u2013            <p>Edge data view objects providing access to edge attributes for each edge (us[i], vs[i]).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def edges_data(self, us: np.ndarray, vs: np.ndarray) -&gt; Iterator:\n    \"\"\"Iterate over edge data for specified edges.\n\n    The arrays `us` and `vs` must have the same length. The edge data\n    objects provide access to edge attributes as defined by the\n    `edge_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    us : np.ndarray\n        Array of source node identifiers.\n    vs : np.ndarray\n        Array of target node identifiers.\n\n    Yields\n    ------\n    Any\n        Edge data view objects providing access to edge attributes\n        for each edge (us[i], vs[i]).\n    \"\"\"\n    return self._cgraph.edges_data(us, vs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.edges_data(us)","title":"<code>us</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of source node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.edges_data(vs)","title":"<code>vs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of target node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.nodes_data","title":"nodes_data","text":"<pre><code>nodes_data(\n    nodes: ndarray | None = None,\n) -&gt; Iterator[tuple[Any, Any]]\n</code></pre> <p>Iterate over nodes and their associated data.</p> <p>The node_data object provides access to node attributes as defined by the <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[Any, Any]</code>           \u2013            <p>Tuples of (node_id, node_data) where node_data is a view object providing access to the node's attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def nodes_data(self, nodes: np.ndarray | None = None) -&gt; Iterator[tuple[Any, Any]]:\n    \"\"\"Iterate over nodes and their associated data.\n\n    The node_data object provides access to node attributes as defined\n    by the `node_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    nodes : np.ndarray, optional\n        Array of specific node identifiers to iterate over. If None,\n        iterates over all nodes in the graph.\n\n    Yields\n    ------\n    tuple[Any, Any]\n        Tuples of (node_id, node_data) where node_data is a view object\n        providing access to the node's attributes.\n    \"\"\"\n    return self._cgraph.nodes_data(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.nodes_data(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of specific node identifiers to iterate over. If None, iterates over all nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.num_edges","title":"num_edges","text":"<pre><code>num_edges() -&gt; int\n</code></pre> <p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def num_edges(self) -&gt; int:\n    \"\"\"Get the total number of edges in the graph.\n\n    Returns\n    -------\n    int\n        The number of edges in the graph.\n    \"\"\"\n    return self._cgraph.num_edges()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: Any) -&gt; None\n</code></pre> <p>Remove a single node from the graph.</p> <p>Removing a node will also remove all edges incident to that node.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Remove a single node from the graph.\n\n    Removing a node will also remove all edges incident to that node.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_node(node)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.remove_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.remove_nodes","title":"remove_nodes","text":"<pre><code>remove_nodes(nodes: ndarray) -&gt; None\n</code></pre> <p>Remove multiple nodes from the graph.</p> <p>Removing nodes will also remove all edges incident to those nodes.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_nodes(self, nodes: np.ndarray) -&gt; None:\n    \"\"\"Remove multiple nodes from the graph.\n\n    Removing nodes will also remove all edges incident to those nodes.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase.remove_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree","title":"LineRTree","text":"<pre><code>LineRTree(item_dtype: str, coord_dtype: str, dims: int)\n</code></pre> <p>               Bases: <code>spatial_graph._rtree.rtree.RTree</code></p> <p>Methods:</p> <ul> <li> <code>bounding_box</code>             \u2013              <p>Get the total bounding box of all items in this RTree.</p> </li> <li> <code>count</code>             \u2013              <p>Count the number of items in a bounding box.</p> </li> <li> <code>delete_item</code>             \u2013              <p>Delete a single item.</p> </li> <li> <code>delete_items</code>             \u2013              <p>Delete items by their content and bounding box.</p> </li> <li> <code>insert_bb_items</code>             \u2013              <p>Insert items with bounding boxes.</p> </li> <li> <code>insert_line</code>             \u2013              <p>Convenience function to insert a single line. To insert multiple</p> </li> <li> <code>insert_lines</code>             \u2013              <p>Insert a list of lines.</p> </li> <li> <code>insert_point_item</code>             \u2013              <p>Insert a single point item.</p> </li> <li> <code>insert_point_items</code>             \u2013              <p>Insert a list of point items.</p> </li> <li> <code>nearest</code>             \u2013              <p>Find the nearest items to a given point.</p> </li> <li> <code>search</code>             \u2013              <p>Search for items in a bounding box.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>c_converter_functions</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_distance_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_equal_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>pyx_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> </ul> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype: str, coord_dtype: str, dims: int):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n    self.coord_dtype = DType(coord_dtype)\n    self.dims = dims\n\n    tree_cls = _compile_tree(self.__class__, item_dtype, coord_dtype, dims)\n    self._ctree = tree_cls()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_converter_functions","title":"c_converter_functions  <code>class</code>","text":"<pre><code>c_converter_functions = \"\\ninline item_t convert_pyx_to_c_item(pyx_item_t *pyx_item,\\n                                    coord_t *start, coord_t *end) {\\n    item_t item;\\n    coord_t tmp;\\n    item.u = (*pyx_item)[0];\\n    item.v = (*pyx_item)[1];\\n    for (int d = 0; d &lt; DIMS; d++) {\\n        item.corner_mask[d] = (start[d] &lt; end[d]);\\n        if (!item.corner_mask[d]) {\\n            // swap coordinates to create bounding box\\n            tmp = start[d];\\n            start[d] = end[d];\\n            end[d] = tmp;\\n        }\\n    }\\n    return item;\\n}\\ninline void copy_c_to_pyx_item(const item_t c_item, pyx_item_t *pyx_item) {\\n    (*pyx_item)[0] = c_item.u;\\n    (*pyx_item)[1] = c_item.v;\\n}\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_distance_function","title":"c_distance_function  <code>class</code>","text":"<pre><code>c_distance_function = '\\ninline coord_t length2(const coord_t x[]) {\\n    coord_t length2 = 0;\\n    for (int d = 0; d &lt; DIMS; d++) {\\n        length2 += pow(x[d], 2);\\n    }\\n    return length2;\\n}\\n\\ninline coord_t point_segment_dist2(const coord_t point[], const coord_t start[],\\n                                   const coord_t end[]) {\\n\\n    coord_t a[DIMS];\\n    coord_t b[DIMS];\\n    coord_t alpha = 0;\\n\\n    for (int d = 0; d &lt; DIMS; d++) {\\n\\n        // subtract \"start\" from \"end\" and \"point\" to get \"a\" and \"b\"\\n        a[d] = end[d] - start[d];\\n        b[d] = point[d] - start[d];\\n\\n        // compute dot product \"alpha\" of \"a\" and \"b\"\\n        alpha += a[d] * b[d];\\n    }\\n\\n    // normalize dot product\\n    alpha /= length2(a);\\n\\n    // clip at 0 and 1 (beginning and end of line segment)\\n    alpha = min0(1, max0(0, alpha));\\n\\n    for (int d = 0; d &lt; DIMS; d++) {\\n\\n        // multiply \"a\" by \"alpha\" to obtain closest segment point to \"b\"\\n        a[d] *= alpha;\\n\\n        // subtract \"b\" from \"a\" to get offset\\n        a[d] -= b[d];\\n    }\\n\\n    // compute squared length of offset\\n    return length2(a);\\n}\\n\\nextern inline coord_t distance(\\n    const coord_t point[], const struct rect *rect, const struct item_t item) {\\n    coord_t start[DIMS];\\n    coord_t end[DIMS];\\n    for (int d = 0; d &lt; DIMS; d++) {\\n        if (item.corner_mask[d]) {\\n            start[d] = rect-&gt;min[d];\\n            end[d] = rect-&gt;max[d];\\n        } else {\\n            start[d] = rect-&gt;max[d];\\n            end[d] = rect-&gt;min[d];\\n        }\\n    }\\n    return point_segment_dist2(point, start, end);\\n}\\n'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_equal_function","title":"c_equal_function  <code>class</code>","text":"<pre><code>c_equal_function = \"\\ninline int equal(const item_t a, const item_t b) {\\n    return (a.u == b.u &amp;&amp; a.v == b.v);\\n}\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_item_t_declaration","title":"c_item_t_declaration  <code>class</code>","text":"<pre><code>c_item_t_declaration = \"\\ntypedef struct item_t {\\n    item_base_t u;\\n    item_base_t v;\\n    bool corner_mask[DIMS];\\n} item_t;\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.pyx_item_t_declaration","title":"pyx_item_t_declaration  <code>class</code>","text":"<pre><code>pyx_item_t_declaration = \"\\n    cdef struct item_t:\\n        item_base_t u\\n        item_base_t v\\n        bool corner_mask[DIMS]\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.bounding_box","title":"bounding_box","text":"<pre><code>bounding_box()\n</code></pre> <p>Get the total bounding box of all items in this RTree.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def bounding_box(self):\n    \"\"\"Get the total bounding box of all items in this RTree.\"\"\"\n    return self._ctree.bounding_box()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.count","title":"count","text":"<pre><code>count(bb_min, bb_max)\n</code></pre> <p>Count the number of items in a bounding box.</p> <p>Args:     bb_min (np.ndarray): The minimum point of the bounding box.     bb_max (np.ndarray): The maximum point of the bounding box.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def count(self, bb_min, bb_max):\n    \"\"\"Count the number of items in a bounding box.\n\n    Args:\n        bb_min (np.ndarray): The minimum point of the bounding box.\n        bb_max (np.ndarray): The maximum point of the bounding box.\n    \"\"\"\n    return self._ctree.count(bb_min, bb_max)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.delete_item","title":"delete_item","text":"<pre><code>delete_item(item, bb_min, bb_max=None)\n</code></pre> <p>Delete a single item.</p> <p>To delete multiple items, use <code>delete_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def delete_item(self, item, bb_min, bb_max=None):\n    \"\"\"Delete a single item.\n\n    To delete multiple items, use `delete_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    bb_mins = bb_min[np.newaxis, :]\n    bb_maxs = None if bb_max is None else bb_max[np.newaxis, :]\n    return self._ctree.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.delete_items","title":"delete_items","text":"<pre><code>delete_items(items, bb_mins, bb_maxs=None)\n</code></pre> <p>Delete items by their content and bounding box.</p> <p>Delete items by their content and bounding box. Only items that match both the <code>items</code> row (a scalar or array, depending on <code>item_dtype</code>) and the exact coordinates of their bounding box will be deleted.</p> <p>Args:</p> <pre><code>items (ndarray):\n\n    Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n    array of `k` scalars per item).\n\nbb_mins/bb_maxs (ndarray):\n\n    Array of shape `(n, dims)`, the minimum/maximum points of the\n    bounding boxes per item to delete.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def delete_items(self, items, bb_mins, bb_maxs=None):\n    \"\"\"Delete items by their content and bounding box.\n\n    Delete items by their content and bounding box. Only items that match\n    both the `items` row (a scalar or array, depending on `item_dtype`) and\n    the exact coordinates of their bounding box will be deleted.\n\n    Args:\n\n        items (ndarray):\n\n            Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n            array of `k` scalars per item).\n\n        bb_mins/bb_maxs (ndarray):\n\n            Array of shape `(n, dims)`, the minimum/maximum points of the\n            bounding boxes per item to delete.\n    \"\"\"\n    return self._ctree.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_bb_items","title":"insert_bb_items","text":"<pre><code>insert_bb_items(items, bb_mins, bb_maxs)\n</code></pre> <p>Insert items with bounding boxes. Args:</p> <p>items (ndarray):</p> <pre><code>Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\narray of `k` scalars per item).\n</code></pre> <p>bb_mins/bb_maxs (ndarray):</p> <pre><code>Array of shape `(n, dims)`, the minimum/maximum points of the\nbounding boxes per item to insert.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_bb_items(self, items, bb_mins, bb_maxs):\n    \"\"\"Insert items with bounding boxes.\n    Args:\n\n    items (ndarray):\n\n        Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n        array of `k` scalars per item).\n\n    bb_mins/bb_maxs (ndarray):\n\n        Array of shape `(n, dims)`, the minimum/maximum points of the\n        bounding boxes per item to insert.\n    \"\"\"\n    return self._ctree.insert_bb_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line","title":"insert_line","text":"<pre><code>insert_line(line, start, end)\n</code></pre> <p>Convenience function to insert a single line. To insert multiple lines in bulk, please use the faster <code>insert_lines</code>.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_rtree/line_rtree.py</code> <pre><code>def insert_line(self, line, start, end):\n    \"\"\"Convenience function to insert a single line. To insert multiple\n    lines in bulk, please use the faster `insert_lines`.\n\n    Parameters\n    ----------\n    line : np.ndarray\n        The line identifier (as passed as the `item_dtype` to the\n        constructor).\n    start : np.ndarray\n        The coordinates of the start of the line.\n    end : np.ndarray\n        The coordinates of the end of the line.\n    \"\"\"\n    lines = np.array([line], dtype=self.item_dtype.base)\n    starts = start[np.newaxis]\n    ends = end[np.newaxis]\n    return self._ctree.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line(line)","title":"<code>line</code>","text":"(<code>ndarray</code>)           \u2013            <p>The line identifier (as passed as the <code>item_dtype</code> to the constructor).</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line(start)","title":"<code>start</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the start of the line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line(end)","title":"<code>end</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the end of the line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines","title":"insert_lines","text":"<pre><code>insert_lines(lines, starts, ends)\n</code></pre> <p>Insert a list of lines.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_rtree/line_rtree.py</code> <pre><code>def insert_lines(self, lines, starts, ends):\n    \"\"\"Insert a list of lines.\n\n    Parameters\n    ----------\n    lines : np.ndarray, shape `(n, [m])`:\n        Array containing the line identifiers (as passed as the\n        `item_dtype` to the constructor). If the identifiers are an\n        array of size `m`, the expected shape is `(n, m)` where `n` is\n        the number of lines, otherwise the shape is just `(n,)`.\n\n    starts : np.ndarray, shape `(n, d)`:\n        The coordinates of the start of each line.\n\n    ends : np.ndarray, shape `(n, d)`:\n        The coordinates of the end of each line.\n    \"\"\"\n    # we just forward to bb insert, \"start\" and \"end\" will be used to compute\n    # the bounding box in our custom converter above\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines(lines)","title":"<code>lines</code>","text":"(<code>np.ndarray, shape `(n, [m])`:</code>)           \u2013            <p>Array containing the line identifiers (as passed as the <code>item_dtype</code> to the constructor). If the identifiers are an array of size <code>m</code>, the expected shape is <code>(n, m)</code> where <code>n</code> is the number of lines, otherwise the shape is just <code>(n,)</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines(starts)","title":"<code>starts</code>","text":"(<code>np.ndarray, shape `(n, d)`:</code>)           \u2013            <p>The coordinates of the start of each line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines(ends)","title":"<code>ends</code>","text":"(<code>np.ndarray, shape `(n, d)`:</code>)           \u2013            <p>The coordinates of the end of each line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_point_item","title":"insert_point_item","text":"<pre><code>insert_point_item(item, position)\n</code></pre> <p>Insert a single point item.</p> <p>To insert multiple points, use <code>insert_point_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_point_item(self, item, position):\n    \"\"\"Insert a single point item.\n\n    To insert multiple points, use `insert_point_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    positions = position[np.newaxis]\n    return self._ctree.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_point_items","title":"insert_point_items","text":"<pre><code>insert_point_items(items, positions)\n</code></pre> <p>Insert a list of point items.</p> <p>Args:</p> <pre><code>items (ndarray):\n\n    Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n    array of `k` scalars per item).\n\npoints (ndarray):\n\n    Array of shape `(n, dims)`, the positions of the points to\n    insert.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_point_items(self, items, positions):\n    \"\"\"Insert a list of point items.\n\n    Args:\n\n        items (ndarray):\n\n            Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n            array of `k` scalars per item).\n\n        points (ndarray):\n\n            Array of shape `(n, dims)`, the positions of the points to\n            insert.\n    \"\"\"\n    return self._ctree.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.nearest","title":"nearest","text":"<pre><code>nearest(point, k=1, return_distances=False)\n</code></pre> <p>Find the nearest items to a given point.</p> <p>Args:</p> <pre><code>point (ndarray):\n\n    The coordinates of the query point.\n\nk (int):\n\n    The maximal number of items to return.\n\nreturn_distances (bool):\n\n    If `True`, return a tuple of `(items, distances)`, where\n    `distances` contains the distance of each found item to the\n    query point.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def nearest(self, point, k=1, return_distances=False):\n    \"\"\"Find the nearest items to a given point.\n\n    Args:\n\n        point (ndarray):\n\n            The coordinates of the query point.\n\n        k (int):\n\n            The maximal number of items to return.\n\n        return_distances (bool):\n\n            If `True`, return a tuple of `(items, distances)`, where\n            `distances` contains the distance of each found item to the\n            query point.\n    \"\"\"\n    return self._ctree.nearest(point, k, return_distances)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.search","title":"search","text":"<pre><code>search(bb_min, bb_max)\n</code></pre> <p>Search for items in a bounding box.</p> <p>Args:     bb_min (np.ndarray): The minimum point of the bounding box.     bb_max (np.ndarray): The maximum point of the bounding box.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def search(self, bb_min, bb_max):\n    \"\"\"Search for items in a bounding box.\n\n    Args:\n        bb_min (np.ndarray): The minimum point of the bounding box.\n        bb_max (np.ndarray): The maximum point of the bounding box.\n    \"\"\"\n    return self._ctree.search(bb_min, bb_max)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree","title":"PointRTree","text":"<pre><code>PointRTree(item_dtype: str, coord_dtype: str, dims: int)\n</code></pre> <p>               Bases: <code>spatial_graph._rtree.rtree.RTree</code></p> <p>Methods:</p> <ul> <li> <code>bounding_box</code>             \u2013              <p>Get the total bounding box of all items in this RTree.</p> </li> <li> <code>count</code>             \u2013              <p>Count the number of items in a bounding box.</p> </li> <li> <code>delete_item</code>             \u2013              <p>Delete a single item.</p> </li> <li> <code>delete_items</code>             \u2013              <p>Delete items by their content and bounding box.</p> </li> <li> <code>insert_bb_items</code>             \u2013              <p>Insert items with bounding boxes.</p> </li> <li> <code>insert_point_item</code>             \u2013              <p>Insert a single point item.</p> </li> <li> <code>insert_point_items</code>             \u2013              <p>Insert a list of point items.</p> </li> <li> <code>nearest</code>             \u2013              <p>Find the nearest items to a given point.</p> </li> <li> <code>search</code>             \u2013              <p>Search for items in a bounding box.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>c_converter_functions</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_distance_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_equal_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>pyx_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> </ul> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype: str, coord_dtype: str, dims: int):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n    self.coord_dtype = DType(coord_dtype)\n    self.dims = dims\n\n    tree_cls = _compile_tree(self.__class__, item_dtype, coord_dtype, dims)\n    self._ctree = tree_cls()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_converter_functions","title":"c_converter_functions  <code>class</code>","text":"<pre><code>c_converter_functions = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_distance_function","title":"c_distance_function  <code>class</code>","text":"<pre><code>c_distance_function = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_equal_function","title":"c_equal_function  <code>class</code>","text":"<pre><code>c_equal_function = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_item_t_declaration","title":"c_item_t_declaration  <code>class</code>","text":"<pre><code>c_item_t_declaration = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.pyx_item_t_declaration","title":"pyx_item_t_declaration  <code>class</code>","text":"<pre><code>pyx_item_t_declaration = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.bounding_box","title":"bounding_box","text":"<pre><code>bounding_box()\n</code></pre> <p>Get the total bounding box of all items in this RTree.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def bounding_box(self):\n    \"\"\"Get the total bounding box of all items in this RTree.\"\"\"\n    return self._ctree.bounding_box()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.count","title":"count","text":"<pre><code>count(bb_min, bb_max)\n</code></pre> <p>Count the number of items in a bounding box.</p> <p>Args:     bb_min (np.ndarray): The minimum point of the bounding box.     bb_max (np.ndarray): The maximum point of the bounding box.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def count(self, bb_min, bb_max):\n    \"\"\"Count the number of items in a bounding box.\n\n    Args:\n        bb_min (np.ndarray): The minimum point of the bounding box.\n        bb_max (np.ndarray): The maximum point of the bounding box.\n    \"\"\"\n    return self._ctree.count(bb_min, bb_max)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.delete_item","title":"delete_item","text":"<pre><code>delete_item(item, bb_min, bb_max=None)\n</code></pre> <p>Delete a single item.</p> <p>To delete multiple items, use <code>delete_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def delete_item(self, item, bb_min, bb_max=None):\n    \"\"\"Delete a single item.\n\n    To delete multiple items, use `delete_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    bb_mins = bb_min[np.newaxis, :]\n    bb_maxs = None if bb_max is None else bb_max[np.newaxis, :]\n    return self._ctree.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.delete_items","title":"delete_items","text":"<pre><code>delete_items(items, bb_mins, bb_maxs=None)\n</code></pre> <p>Delete items by their content and bounding box.</p> <p>Delete items by their content and bounding box. Only items that match both the <code>items</code> row (a scalar or array, depending on <code>item_dtype</code>) and the exact coordinates of their bounding box will be deleted.</p> <p>Args:</p> <pre><code>items (ndarray):\n\n    Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n    array of `k` scalars per item).\n\nbb_mins/bb_maxs (ndarray):\n\n    Array of shape `(n, dims)`, the minimum/maximum points of the\n    bounding boxes per item to delete.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def delete_items(self, items, bb_mins, bb_maxs=None):\n    \"\"\"Delete items by their content and bounding box.\n\n    Delete items by their content and bounding box. Only items that match\n    both the `items` row (a scalar or array, depending on `item_dtype`) and\n    the exact coordinates of their bounding box will be deleted.\n\n    Args:\n\n        items (ndarray):\n\n            Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n            array of `k` scalars per item).\n\n        bb_mins/bb_maxs (ndarray):\n\n            Array of shape `(n, dims)`, the minimum/maximum points of the\n            bounding boxes per item to delete.\n    \"\"\"\n    return self._ctree.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.insert_bb_items","title":"insert_bb_items","text":"<pre><code>insert_bb_items(items, bb_mins, bb_maxs)\n</code></pre> <p>Insert items with bounding boxes. Args:</p> <p>items (ndarray):</p> <pre><code>Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\narray of `k` scalars per item).\n</code></pre> <p>bb_mins/bb_maxs (ndarray):</p> <pre><code>Array of shape `(n, dims)`, the minimum/maximum points of the\nbounding boxes per item to insert.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_bb_items(self, items, bb_mins, bb_maxs):\n    \"\"\"Insert items with bounding boxes.\n    Args:\n\n    items (ndarray):\n\n        Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n        array of `k` scalars per item).\n\n    bb_mins/bb_maxs (ndarray):\n\n        Array of shape `(n, dims)`, the minimum/maximum points of the\n        bounding boxes per item to insert.\n    \"\"\"\n    return self._ctree.insert_bb_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.insert_point_item","title":"insert_point_item","text":"<pre><code>insert_point_item(item, position)\n</code></pre> <p>Insert a single point item.</p> <p>To insert multiple points, use <code>insert_point_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_point_item(self, item, position):\n    \"\"\"Insert a single point item.\n\n    To insert multiple points, use `insert_point_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    positions = position[np.newaxis]\n    return self._ctree.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.insert_point_items","title":"insert_point_items","text":"<pre><code>insert_point_items(items, positions)\n</code></pre> <p>Insert a list of point items.</p> <p>Args:</p> <pre><code>items (ndarray):\n\n    Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n    array of `k` scalars per item).\n\npoints (ndarray):\n\n    Array of shape `(n, dims)`, the positions of the points to\n    insert.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_point_items(self, items, positions):\n    \"\"\"Insert a list of point items.\n\n    Args:\n\n        items (ndarray):\n\n            Array of shape `(n,)` (one scalar per item) or `(n, k)` (one\n            array of `k` scalars per item).\n\n        points (ndarray):\n\n            Array of shape `(n, dims)`, the positions of the points to\n            insert.\n    \"\"\"\n    return self._ctree.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.nearest","title":"nearest","text":"<pre><code>nearest(point, k=1, return_distances=False)\n</code></pre> <p>Find the nearest items to a given point.</p> <p>Args:</p> <pre><code>point (ndarray):\n\n    The coordinates of the query point.\n\nk (int):\n\n    The maximal number of items to return.\n\nreturn_distances (bool):\n\n    If `True`, return a tuple of `(items, distances)`, where\n    `distances` contains the distance of each found item to the\n    query point.\n</code></pre> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def nearest(self, point, k=1, return_distances=False):\n    \"\"\"Find the nearest items to a given point.\n\n    Args:\n\n        point (ndarray):\n\n            The coordinates of the query point.\n\n        k (int):\n\n            The maximal number of items to return.\n\n        return_distances (bool):\n\n            If `True`, return a tuple of `(items, distances)`, where\n            `distances` contains the distance of each found item to the\n            query point.\n    \"\"\"\n    return self._ctree.nearest(point, k, return_distances)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.search","title":"search","text":"<pre><code>search(bb_min, bb_max)\n</code></pre> <p>Search for items in a bounding box.</p> <p>Args:     bb_min (np.ndarray): The minimum point of the bounding box.     bb_max (np.ndarray): The maximum point of the bounding box.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def search(self, bb_min, bb_max):\n    \"\"\"Search for items in a bounding box.\n\n    Args:\n        bb_min (np.ndarray): The minimum point of the bounding box.\n        bb_max (np.ndarray): The maximum point of the bounding box.\n    \"\"\"\n    return self._ctree.search(bb_min, bb_max)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph","title":"SpatialDiGraph","text":"<pre><code>SpatialDiGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._spatial_graph.SpatialGraphBase</code>, <code>spatial_graph._graph.graph.DiGraph</code></p> <p>Base class for directed spatial graph instances.</p> <p>Methods:</p> <ul> <li> <code>edges_data</code>             \u2013              <p>Iterate over edge data for specified edges.</p> </li> <li> <code>in_edges</code>             \u2013              <p>Iterate over incoming edges to a node.</p> </li> <li> <code>in_edges_by_nodes</code>             \u2013              <p>Get all incoming edges to the specified nodes.</p> </li> <li> <code>nodes_data</code>             \u2013              <p>Iterate over nodes and their associated data.</p> </li> <li> <code>num_edges</code>             \u2013              <p>Get the total number of edges in the graph.</p> </li> <li> <code>num_in_neighbors</code>             \u2013              <p>Return the number of incoming neighbors for each node.</p> </li> <li> <code>num_out_neighbors</code>             \u2013              <p>Return the number of outgoing neighbors for each node.</p> </li> <li> <code>out_edges</code>             \u2013              <p>Iterate over outgoing edges from a node.</p> </li> <li> <code>out_edges_by_nodes</code>             \u2013              <p>Get all outgoing edges from the specified nodes.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a single node from the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>directed</code>           \u2013            <p>bool(x) -&gt; bool</p> </li> <li> <code>edge_inclusion_values</code>           \u2013            <p>Built-in mutable sequence.</p> </li> <li> <code>nodes</code>           \u2013            <p>Get all node IDs in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.directed","title":"directed  <code>class</code>","text":"<pre><code>directed = True\n</code></pre> <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.edge_inclusion_values","title":"edge_inclusion_values  <code>class</code>","text":"<pre><code>edge_inclusion_values = ['incident', 'leaving', 'entering']\n</code></pre> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Get all node IDs in the graph.</p> <p>The returned array is a copy and modifications will not affect the graph structure.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing all node identifiers in the graph, ordered by insertion order (earliest added first).</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.edges_data","title":"edges_data","text":"<pre><code>edges_data(us: ndarray, vs: ndarray) -&gt; Iterator\n</code></pre> <p>Iterate over edge data for specified edges.</p> <p>The arrays <code>us</code> and <code>vs</code> must have the same length. The edge data objects provide access to edge attributes as defined by the <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Any</code>           \u2013            <p>Edge data view objects providing access to edge attributes for each edge (us[i], vs[i]).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def edges_data(self, us: np.ndarray, vs: np.ndarray) -&gt; Iterator:\n    \"\"\"Iterate over edge data for specified edges.\n\n    The arrays `us` and `vs` must have the same length. The edge data\n    objects provide access to edge attributes as defined by the\n    `edge_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    us : np.ndarray\n        Array of source node identifiers.\n    vs : np.ndarray\n        Array of target node identifiers.\n\n    Yields\n    ------\n    Any\n        Edge data view objects providing access to edge attributes\n        for each edge (us[i], vs[i]).\n    \"\"\"\n    return self._cgraph.edges_data(us, vs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.edges_data(us)","title":"<code>us</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of source node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.edges_data(vs)","title":"<code>vs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of target node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.in_edges","title":"in_edges","text":"<pre><code>in_edges(\n    node: Any = None, data: bool = False\n) -&gt; Iterator[tuple]\n</code></pre> <p>Iterate over incoming edges to a node.</p> <p>Only edges directed toward the specified node are yielded.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple or tuple[tuple, Any]</code>           \u2013            <p>If <code>data=False</code>: tuples of (source_node, target_node) representing incoming edges where target_node is the specified node. If <code>data=True</code>: tuples of ((source_node, target_node), edge_data) where edge_data provides access to edge attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def in_edges(self, node: Any = None, data: bool = False) -&gt; Iterator[tuple]:\n    \"\"\"Iterate over incoming edges to a node.\n\n    Only edges directed toward the specified node are yielded.\n\n    Parameters\n    ----------\n    node : Any\n        The target node to find incoming edges for.\n    data : bool\n        If True, yield (edge, edge_data) tuples. If False, yield\n        only edge tuples.\n\n    Yields\n    ------\n    tuple or tuple[tuple, Any]\n        If `data=False`: tuples of (source_node, target_node) representing\n        incoming edges where target_node is the specified node.\n        If `data=True`: tuples of ((source_node, target_node), edge_data)\n        where edge_data provides access to edge attributes.\n    \"\"\"\n    return self._cgraph.in_edges(node, data)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.in_edges(node)","title":"<code>node</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The target node to find incoming edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.in_edges(data)","title":"<code>data</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, yield (edge, edge_data) tuples. If False, yield only edge tuples.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.in_edges_by_nodes","title":"in_edges_by_nodes","text":"<pre><code>in_edges_by_nodes(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Get all incoming edges to the specified nodes.</p> <p>This method provides fast access to incoming edges for an array of nodes. Edges between nodes in the input array will be reported multiple times if both source and target are in the array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node] representing an incoming edge to one of the specified nodes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def in_edges_by_nodes(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get all incoming edges to the specified nodes.\n\n    This method provides fast access to incoming edges for an array\n    of nodes. Edges between nodes in the input array will be reported\n    multiple times if both source and target are in the array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to find incoming edges for.\n\n    Returns\n    -------\n    np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node] representing an incoming edge\n        to one of the specified nodes.\n    \"\"\"\n    return self._cgraph.in_edges_by_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.in_edges_by_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to find incoming edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.nodes_data","title":"nodes_data","text":"<pre><code>nodes_data(\n    nodes: ndarray | None = None,\n) -&gt; Iterator[tuple[Any, Any]]\n</code></pre> <p>Iterate over nodes and their associated data.</p> <p>The node_data object provides access to node attributes as defined by the <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[Any, Any]</code>           \u2013            <p>Tuples of (node_id, node_data) where node_data is a view object providing access to the node's attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def nodes_data(self, nodes: np.ndarray | None = None) -&gt; Iterator[tuple[Any, Any]]:\n    \"\"\"Iterate over nodes and their associated data.\n\n    The node_data object provides access to node attributes as defined\n    by the `node_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    nodes : np.ndarray, optional\n        Array of specific node identifiers to iterate over. If None,\n        iterates over all nodes in the graph.\n\n    Yields\n    ------\n    tuple[Any, Any]\n        Tuples of (node_id, node_data) where node_data is a view object\n        providing access to the node's attributes.\n    \"\"\"\n    return self._cgraph.nodes_data(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.nodes_data(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of specific node identifiers to iterate over. If None, iterates over all nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.num_edges","title":"num_edges","text":"<pre><code>num_edges() -&gt; int\n</code></pre> <p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def num_edges(self) -&gt; int:\n    \"\"\"Get the total number of edges in the graph.\n\n    Returns\n    -------\n    int\n        The number of edges in the graph.\n    \"\"\"\n    return self._cgraph.num_edges()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.num_in_neighbors","title":"num_in_neighbors","text":"<pre><code>num_in_neighbors(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Return the number of incoming neighbors for each node.</p> <p>This counts only nodes that have edges pointing to the specified nodes (i.e., predecessors).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of incoming neighbor counts for each node in the input array.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def num_in_neighbors(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the number of incoming neighbors for each node.\n\n    This counts only nodes that have edges pointing to the specified nodes\n    (i.e., predecessors).\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to count incoming neighbors for.\n\n    Returns\n    -------\n    np.ndarray\n        Array of incoming neighbor counts for each node in the input array.\n    \"\"\"\n    return self._cgraph.num_in_neighbors(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.num_in_neighbors(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to count incoming neighbors for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.num_out_neighbors","title":"num_out_neighbors","text":"<pre><code>num_out_neighbors(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Return the number of outgoing neighbors for each node.</p> <p>This counts only nodes that the specified nodes have edges pointing to (i.e., successors).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of outgoing neighbor counts for each node in the input array.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def num_out_neighbors(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the number of outgoing neighbors for each node.\n\n    This counts only nodes that the specified nodes\n    have edges pointing to (i.e., successors).\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to count outgoing neighbors for.\n\n    Returns\n    -------\n    np.ndarray\n        Array of outgoing neighbor counts for each node in the input array.\n    \"\"\"\n    return self._cgraph.num_out_neighbors(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.num_out_neighbors(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to count outgoing neighbors for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.out_edges","title":"out_edges","text":"<pre><code>out_edges(\n    node: Any = None, data: bool = False\n) -&gt; Iterator[tuple]\n</code></pre> <p>Iterate over outgoing edges from a node.</p> <p>Only edges directed away from the specified node are yielded.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple or tuple[tuple, Any]</code>           \u2013            <p>If <code>data=False</code>: tuples of (source_node, target_node) representing outgoing edges where source_node is the specified node. If <code>data=True</code>: tuples of ((source_node, target_node), edge_data) where edge_data provides access to edge attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def out_edges(self, node: Any = None, data: bool = False) -&gt; Iterator[tuple]:\n    \"\"\"Iterate over outgoing edges from a node.\n\n    Only edges directed away from the specified node are yielded.\n\n    Parameters\n    ----------\n    node : Any\n        The source node to find outgoing edges for.\n    data : bool\n        If True, yield (edge, edge_data) tuples. If False, yield\n        only edge tuples.\n\n    Yields\n    ------\n    tuple or tuple[tuple, Any]\n        If `data=False`: tuples of (source_node, target_node) representing\n        outgoing edges where source_node is the specified node.\n        If `data=True`: tuples of ((source_node, target_node), edge_data)\n        where edge_data provides access to edge attributes.\n    \"\"\"\n    return self._cgraph.out_edges(node, data)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.out_edges(node)","title":"<code>node</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The source node to find outgoing edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.out_edges(data)","title":"<code>data</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, yield (edge, edge_data) tuples. If False, yield only edge tuples.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.out_edges_by_nodes","title":"out_edges_by_nodes","text":"<pre><code>out_edges_by_nodes(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Get all outgoing edges from the specified nodes.</p> <p>This method provides fast access to outgoing edges for an array of nodes. Edges between nodes in the input array will be reported multiple times if both source and target are in the array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [source_node, target_node] representing an outgoing edge from one of the specified nodes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def out_edges_by_nodes(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get all outgoing edges from the specified nodes.\n\n    This method provides fast access to outgoing edges for an array\n    of nodes. Edges between nodes in the input array will be reported\n    multiple times if both source and target are in the array.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to find outgoing edges for.\n\n    Returns\n    -------\n    np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [source_node, target_node] representing an outgoing edge\n        from one of the specified nodes.\n    \"\"\"\n    return self._cgraph.out_edges_by_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.out_edges_by_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to find outgoing edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: Any) -&gt; None\n</code></pre> <p>Remove a single node from the graph.</p> <p>Removing a node will also remove all edges incident to that node.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Remove a single node from the graph.\n\n    Removing a node will also remove all edges incident to that node.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_node(node)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.remove_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph","title":"SpatialGraph","text":"<pre><code>SpatialGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._spatial_graph.SpatialGraphBase</code>, <code>spatial_graph._graph.graph.Graph</code></p> <p>Base class for undirected spatial graph instances.</p> <p>Methods:</p> <ul> <li> <code>edges_by_nodes</code>             \u2013              <p>Get all edges incident to the specified nodes.</p> </li> <li> <code>edges_data</code>             \u2013              <p>Iterate over edge data for specified edges.</p> </li> <li> <code>nodes_data</code>             \u2013              <p>Iterate over nodes and their associated data.</p> </li> <li> <code>num_edges</code>             \u2013              <p>Get the total number of edges in the graph.</p> </li> <li> <code>num_neighbors</code>             \u2013              <p>Return the number of neighbors for each node.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a single node from the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>directed</code>           \u2013            <p>bool(x) -&gt; bool</p> </li> <li> <code>edge_inclusion_values</code>           \u2013            <p>Built-in mutable sequence.</p> </li> <li> <code>nodes</code>           \u2013            <p>Get all node IDs in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.directed","title":"directed  <code>class</code>","text":"<pre><code>directed = False\n</code></pre> <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edge_inclusion_values","title":"edge_inclusion_values  <code>class</code>","text":"<pre><code>edge_inclusion_values = ['incident', 'leaving', 'entering']\n</code></pre> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Get all node IDs in the graph.</p> <p>The returned array is a copy and modifications will not affect the graph structure.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing all node identifiers in the graph, ordered by insertion order (earliest added first).</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edges_by_nodes","title":"edges_by_nodes","text":"<pre><code>edges_by_nodes(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Get all edges incident to the specified nodes.</p> <p>This method provides fast access to edges incident to an array of nodes. Note that edges between nodes in the input array will be reported multiple times (once for each incident node).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>2D array of shape (n_edges, 2) where each row contains [node1, node2] representing an edge. For undirected graphs, node1 &lt;= node2.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def edges_by_nodes(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get all edges incident to the specified nodes.\n\n    This method provides fast access to edges incident to an array\n    of nodes. Note that edges between nodes in the input array will\n    be reported multiple times (once for each incident node).\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to find incident edges for.\n\n    Returns\n    -------\n    np.ndarray\n        2D array of shape (n_edges, 2) where each row contains\n        [node1, node2] representing an edge. For undirected graphs,\n        node1 &lt;= node2.\n    \"\"\"\n    return self._cgraph.edges_by_nodes(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edges_by_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to find incident edges for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edges_data","title":"edges_data","text":"<pre><code>edges_data(us: ndarray, vs: ndarray) -&gt; Iterator\n</code></pre> <p>Iterate over edge data for specified edges.</p> <p>The arrays <code>us</code> and <code>vs</code> must have the same length. The edge data objects provide access to edge attributes as defined by the <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Any</code>           \u2013            <p>Edge data view objects providing access to edge attributes for each edge (us[i], vs[i]).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def edges_data(self, us: np.ndarray, vs: np.ndarray) -&gt; Iterator:\n    \"\"\"Iterate over edge data for specified edges.\n\n    The arrays `us` and `vs` must have the same length. The edge data\n    objects provide access to edge attributes as defined by the\n    `edge_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    us : np.ndarray\n        Array of source node identifiers.\n    vs : np.ndarray\n        Array of target node identifiers.\n\n    Yields\n    ------\n    Any\n        Edge data view objects providing access to edge attributes\n        for each edge (us[i], vs[i]).\n    \"\"\"\n    return self._cgraph.edges_data(us, vs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edges_data(us)","title":"<code>us</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of source node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edges_data(vs)","title":"<code>vs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of target node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.nodes_data","title":"nodes_data","text":"<pre><code>nodes_data(\n    nodes: ndarray | None = None,\n) -&gt; Iterator[tuple[Any, Any]]\n</code></pre> <p>Iterate over nodes and their associated data.</p> <p>The node_data object provides access to node attributes as defined by the <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[Any, Any]</code>           \u2013            <p>Tuples of (node_id, node_data) where node_data is a view object providing access to the node's attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def nodes_data(self, nodes: np.ndarray | None = None) -&gt; Iterator[tuple[Any, Any]]:\n    \"\"\"Iterate over nodes and their associated data.\n\n    The node_data object provides access to node attributes as defined\n    by the `node_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    nodes : np.ndarray, optional\n        Array of specific node identifiers to iterate over. If None,\n        iterates over all nodes in the graph.\n\n    Yields\n    ------\n    tuple[Any, Any]\n        Tuples of (node_id, node_data) where node_data is a view object\n        providing access to the node's attributes.\n    \"\"\"\n    return self._cgraph.nodes_data(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.nodes_data(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of specific node identifiers to iterate over. If None, iterates over all nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.num_edges","title":"num_edges","text":"<pre><code>num_edges() -&gt; int\n</code></pre> <p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def num_edges(self) -&gt; int:\n    \"\"\"Get the total number of edges in the graph.\n\n    Returns\n    -------\n    int\n        The number of edges in the graph.\n    \"\"\"\n    return self._cgraph.num_edges()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.num_neighbors","title":"num_neighbors","text":"<pre><code>num_neighbors(nodes: ndarray) -&gt; np.ndarray\n</code></pre> <p>Return the number of neighbors for each node.</p> <p>For undirected graphs, this counts all adjacent nodes regardless of edge direction since edges are bidirectional.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of neighbor counts for each node in the input array.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def num_neighbors(self, nodes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the number of neighbors for each node.\n\n    For undirected graphs, this counts all adjacent nodes regardless\n    of edge direction since edges are bidirectional.\n\n    Parameters\n    ----------\n    nodes : np.ndarray\n        Array of node identifiers to count neighbors for.\n\n    Returns\n    -------\n    np.ndarray\n        Array of neighbor counts for each node in the input array.\n    \"\"\"\n    return self._cgraph.num_neighbors(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.num_neighbors(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of node identifiers to count neighbors for.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: Any) -&gt; None\n</code></pre> <p>Remove a single node from the graph.</p> <p>Removing a node will also remove all edges incident to that node.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Remove a single node from the graph.\n\n    Removing a node will also remove all edges incident to that node.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_node(node)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.remove_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase","title":"SpatialGraphBase","text":"<pre><code>SpatialGraphBase(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._graph.graph_base.GraphBase</code></p> <p>Methods:</p> <ul> <li> <code>edges_data</code>             \u2013              <p>Iterate over edge data for specified edges.</p> </li> <li> <code>nodes_data</code>             \u2013              <p>Iterate over nodes and their associated data.</p> </li> <li> <code>num_edges</code>             \u2013              <p>Get the total number of edges in the graph.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a single node from the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>directed</code>           \u2013            <p>bool(x) -&gt; bool</p> </li> <li> <code>edge_inclusion_values</code>           \u2013            <p>Built-in mutable sequence.</p> </li> <li> <code>nodes</code>           \u2013            <p>Get all node IDs in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.directed","title":"directed  <code>class</code>","text":"<pre><code>directed = False\n</code></pre> <p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.edge_inclusion_values","title":"edge_inclusion_values  <code>class</code>","text":"<pre><code>edge_inclusion_values = ['incident', 'leaving', 'entering']\n</code></pre> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Get all node IDs in the graph.</p> <p>The returned array is a copy and modifications will not affect the graph structure.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing all node identifiers in the graph, ordered by insertion order (earliest added first).</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.edges_data","title":"edges_data","text":"<pre><code>edges_data(us: ndarray, vs: ndarray) -&gt; Iterator\n</code></pre> <p>Iterate over edge data for specified edges.</p> <p>The arrays <code>us</code> and <code>vs</code> must have the same length. The edge data objects provide access to edge attributes as defined by the <code>edge_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Any</code>           \u2013            <p>Edge data view objects providing access to edge attributes for each edge (us[i], vs[i]).</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def edges_data(self, us: np.ndarray, vs: np.ndarray) -&gt; Iterator:\n    \"\"\"Iterate over edge data for specified edges.\n\n    The arrays `us` and `vs` must have the same length. The edge data\n    objects provide access to edge attributes as defined by the\n    `edge_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    us : np.ndarray\n        Array of source node identifiers.\n    vs : np.ndarray\n        Array of target node identifiers.\n\n    Yields\n    ------\n    Any\n        Edge data view objects providing access to edge attributes\n        for each edge (us[i], vs[i]).\n    \"\"\"\n    return self._cgraph.edges_data(us, vs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.edges_data(us)","title":"<code>us</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of source node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.edges_data(vs)","title":"<code>vs</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of target node identifiers.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.nodes_data","title":"nodes_data","text":"<pre><code>nodes_data(\n    nodes: ndarray | None = None,\n) -&gt; Iterator[tuple[Any, Any]]\n</code></pre> <p>Iterate over nodes and their associated data.</p> <p>The node_data object provides access to node attributes as defined by the <code>node_attr_dtypes</code> when the graph was created.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[Any, Any]</code>           \u2013            <p>Tuples of (node_id, node_data) where node_data is a view object providing access to the node's attributes.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def nodes_data(self, nodes: np.ndarray | None = None) -&gt; Iterator[tuple[Any, Any]]:\n    \"\"\"Iterate over nodes and their associated data.\n\n    The node_data object provides access to node attributes as defined\n    by the `node_attr_dtypes` when the graph was created.\n\n    Parameters\n    ----------\n    nodes : np.ndarray, optional\n        Array of specific node identifiers to iterate over. If None,\n        iterates over all nodes in the graph.\n\n    Yields\n    ------\n    tuple[Any, Any]\n        Tuples of (node_id, node_data) where node_data is a view object\n        providing access to the node's attributes.\n    \"\"\"\n    return self._cgraph.nodes_data(nodes)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.nodes_data(nodes)","title":"<code>nodes</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of specific node identifiers to iterate over. If None, iterates over all nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.num_edges","title":"num_edges","text":"<pre><code>num_edges() -&gt; int\n</code></pre> <p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of edges in the graph.</p> </li> </ul> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def num_edges(self) -&gt; int:\n    \"\"\"Get the total number of edges in the graph.\n\n    Returns\n    -------\n    int\n        The number of edges in the graph.\n    \"\"\"\n    return self._cgraph.num_edges()\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: Any) -&gt; None\n</code></pre> <p>Remove a single node from the graph.</p> <p>Removing a node will also remove all edges incident to that node.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_graph/graph_base.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Remove a single node from the graph.\n\n    Removing a node will also remove all edges incident to that node.\n\n    Parameters\n    ----------\n    node : Any\n        The node identifier to remove from the graph.\n    \"\"\"\n    return self._cgraph.remove_node(node)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.remove_node(node)","title":"<code>node</code>","text":"(<code>Any</code>)           \u2013            <p>The node identifier to remove from the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph","title":"create_graph","text":"<pre><code>create_graph(\n    node_dtype: str,\n    ndims: int | None = None,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str | None = None,\n    directed: bool = False,\n) -&gt; Graph | DiGraph | SpatialGraph | SpatialDiGraph\n</code></pre> <p>Convenience factory function to create a graph instance.</p> <p>This will create the appropriate graph type based on the parameters provided. If <code>ndims</code> is specified, it will create a spatial graph; otherwise, it will create a non-spatial graph. If <code>directed</code> is True, it will create a directed graph; otherwise, it will create an undirected graph.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_util.py</code> <pre><code>def create_graph(\n    node_dtype: str,\n    ndims: int | None = None,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str | None = None,\n    directed: bool = False,\n) -&gt; Graph | DiGraph | SpatialGraph | SpatialDiGraph:\n    \"\"\"Convenience factory function to create a graph instance.\n\n    This will create the appropriate graph type based on the parameters provided.\n    If `ndims` is specified, it will create a spatial graph; otherwise, it will create\n    a non-spatial graph. If `directed` is True, it will create a directed graph;\n    otherwise, it will create an undirected graph.\n\n    Parameters\n    ----------\n    node_dtype : str\n        The data type of the nodes in the graph.\n    ndims : int or None, optional\n        The number of dimensions for spatial graphs. If None, the graph is non-spatial.\n    node_attr_dtypes : Mapping[str, str], optional\n        A mapping of node attribute names to their data types.\n    edge_attr_dtypes : Mapping[str, str], optional\n        A mapping of edge attribute names to their data types.\n    position_attr : str, optional\n        The name of the attribute that holds the position of nodes in spatial graphs.\n    directed : bool, optional\n        Whether the graph is directed or not. Defaults to False.\n    \"\"\"\n    if ndims is not None:  # Spatial graph\n        cls = SpatialDiGraph if directed else SpatialGraph\n        return cls(\n            ndims=ndims,\n            node_dtype=node_dtype,\n            node_attr_dtypes=node_attr_dtypes,\n            edge_attr_dtypes=edge_attr_dtypes,\n            position_attr=position_attr or \"position\",\n        )\n    else:\n        if position_attr is not None:  # pragma: no cover\n            warnings.warn(\n                \"'position_attr' is ignored when 'ndims' is not specified.\",\n                UserWarning,\n                stacklevel=2,\n            )\n\n        cls_ = DiGraph if directed else Graph\n        return cls_(\n            node_dtype=node_dtype,\n            node_attr_dtypes=node_attr_dtypes,\n            edge_attr_dtypes=edge_attr_dtypes,\n        )\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(node_dtype)","title":"<code>node_dtype</code>","text":"(<code>str</code>)           \u2013            <p>The data type of the nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(ndims)","title":"<code>ndims</code>","text":"(<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>The number of dimensions for spatial graphs. If None, the graph is non-spatial.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(node_attr_dtypes)","title":"<code>node_attr_dtypes</code>","text":"(<code>Mapping[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of node attribute names to their data types.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(edge_attr_dtypes)","title":"<code>edge_attr_dtypes</code>","text":"(<code>Mapping[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of edge attribute names to their data types.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the attribute that holds the position of nodes in spatial graphs.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(directed)","title":"<code>directed</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the graph is directed or not. Defaults to False.</p>"}]}