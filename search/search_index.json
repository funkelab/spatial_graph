{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spatial-graph","text":"<p><code>spatial-graph</code> provides a data structure for directed and undirected graphs, where each node has an nD position (in time or space).</p> <p>It leverages well-in-time compiled C++ code for efficient graph operations, coupled with an rtree implementation for fast spatial queries.</p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Support for arbitrary number of dimensions</li> <li>Typed node identifiers and attributes<ul> <li>Any fixed-length type that is supported by <code>numpy</code></li> </ul> </li> <li>Efficient node/edge queries by<ul> <li>ROI</li> <li>kNN (by points / lines)</li> </ul> </li> <li>numpy-like interface for efficient:<ul> <li>Graph population and manipulation</li> <li>Query results</li> <li>Attribute access</li> </ul> </li> <li>Minimal memory footprint</li> <li>Minimal dependencies</li> <li>PYX API for graph algorithms in C/C++</li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Graph creation:</p> <pre><code>graph = sg.SpatialGraph(\n    ndims=3,\n    node_dtype=\"uint64\",\n    node_attr_dtypes={\"position\": \"double[3]\"},\n    edge_attr_dtypes={\"score\": \"float32\"},\n    position_attr=\"position\",\n)\n</code></pre> <p>Adding nodes/edges:</p> <pre><code>graph.add_nodes(\n    np.array([1, 2, 3, 4, 5], dtype=\"uint64\"),\n    position=np.array(\n        [\n            [0.1, 0.1, 0.1],\n            [0.2, 0.2, 0.2],\n            [0.3, 0.3, 0.3],\n            [0.4, 0.4, 0.4],\n            [0.5, 0.5, 0.5],\n        ],\n        dtype=\"double\",\n    ),\n)\n\ngraph.add_edges(\n    np.array([[1, 2], [3, 4], [5, 1]], dtype=\"uint64\"),\n    score=np.array([0.2, 0.3, 0.4], dtype=\"float32\"),\n)\n</code></pre> <p>Query nodes/edges in ROI:</p> <pre><code># nodes/edges will be numpy arrays of dtype uint64 and shape (n,)/(n, 2)\nnodes = graph.query_nodes_in_roi(np.array([[0.0, 0.0, 0.0], [0.25, 0.25, 0.25]]))\nedges = graph.query_edges_in_roi(np.array([[0.0, 0.0, 0.0], [0.25, 0.25, 0.25]]))\n</code></pre> <p>Query nodes/edges by position:</p> <pre><code>nodes = graph.query_nearest_nodes(np.array([0.3, 0.3, 0.3]), k=3)\nedges = graph.query_nearest_edges(np.array([0.3, 0.3, 0.3]), k=3)\n</code></pre> <p>Access node/edge attributes:</p> <pre><code>node_positions = graph.node_attrs[nodes].position\nedge_scores = graph.edge_attrs[edges].score\n</code></pre> <p>Delete nodes/edges:</p> <pre><code>graph.remove_nodes(nodes[:1000])\n</code></pre> <p>See the API documentation for more details.</p>"},{"location":"reference/spatial_graph/","title":"spatial_graph","text":""},{"location":"reference/spatial_graph/#spatial_graph","title":"spatial_graph","text":"<p>Classes:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>Base class for directed graph instances.</p> </li> <li> <code>Graph</code>           \u2013            <p>Base class for undirected graph instances.</p> </li> <li> <code>GraphBase</code>           \u2013            <p>Base class for compiled graph instances.</p> </li> <li> <code>LineRTree</code>           \u2013            </li> <li> <code>PointRTree</code>           \u2013            </li> <li> <code>SpatialDiGraph</code>           \u2013            <p>Base class for directed spatial graph instances.</p> </li> <li> <code>SpatialGraph</code>           \u2013            <p>Base class for undirected spatial graph instances.</p> </li> <li> <code>SpatialGraphBase</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>create_graph</code>             \u2013              <p>Convenience factory function to create a graph instance.</p> </li> </ul>"},{"location":"reference/spatial_graph/#spatial_graph.DiGraph","title":"DiGraph","text":"<pre><code>DiGraph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._graph.graph.GraphBase</code></p> <p>Base class for directed graph instances.</p> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.Graph","title":"Graph","text":"<pre><code>Graph(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._graph.graph.GraphBase</code></p> <p>Base class for undirected graph instances.</p> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.GraphBase","title":"GraphBase","text":"<pre><code>GraphBase(\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n)\n</code></pre> <p>Base class for compiled graph instances.</p> Source code in <code>src/spatial_graph/_graph/graph.py</code> <pre><code>def __init__(\n    self,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    directed: bool = False,\n):\n    super().__init__()\n    self.node_dtype = node_dtype\n    self.node_attr_dtypes = node_attr_dtypes or {}\n    self.edge_attr_dtypes = edge_attr_dtypes or {}\n    self.directed = directed\n\n    self.node_attrs = NodeAttrs(self)\n    self.edge_attrs = EdgeAttrs(self)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree","title":"LineRTree","text":"<pre><code>LineRTree(item_dtype, coord_dtype, dims)\n</code></pre> <p>               Bases: <code>spatial_graph._rtree.rtree.RTree</code></p> <p>Methods:</p> <ul> <li> <code>delete_item</code>             \u2013              <p>Delete a single item.</p> </li> <li> <code>insert_line</code>             \u2013              <p>Convenience function to insert a single line. To insert multiple</p> </li> <li> <code>insert_lines</code>             \u2013              <p>Insert a list of lines.</p> </li> <li> <code>insert_point_item</code>             \u2013              <p>Insert a single point item.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>c_converter_functions</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_distance_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_equal_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>pyx_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> </ul> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype, coord_dtype, dims):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_converter_functions","title":"c_converter_functions  <code>class</code>","text":"<pre><code>c_converter_functions = \"\\ninline item_t convert_pyx_to_c_item(pyx_item_t *pyx_item,\\n                                    coord_t *start, coord_t *end) {\\n    item_t item;\\n    coord_t tmp;\\n    item.u = (*pyx_item)[0];\\n    item.v = (*pyx_item)[1];\\n    for (int d = 0; d &lt; DIMS; d++) {\\n        item.corner_mask[d] = (start[d] &lt; end[d]);\\n        if (!item.corner_mask[d]) {\\n            // swap coordinates to create bounding box\\n            tmp = start[d];\\n            start[d] = end[d];\\n            end[d] = tmp;\\n        }\\n    }\\n    return item;\\n}\\ninline void copy_c_to_pyx_item(const item_t c_item, pyx_item_t *pyx_item) {\\n    (*pyx_item)[0] = c_item.u;\\n    (*pyx_item)[1] = c_item.v;\\n}\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_distance_function","title":"c_distance_function  <code>class</code>","text":"<pre><code>c_distance_function = '\\ninline coord_t length2(const coord_t x[]) {\\n    coord_t length2 = 0;\\n    for (int d = 0; d &lt; DIMS; d++) {\\n        length2 += pow(x[d], 2);\\n    }\\n    return length2;\\n}\\n\\ninline coord_t point_segment_dist2(const coord_t point[], const coord_t start[],\\n                                   const coord_t end[]) {\\n\\n    coord_t a[DIMS];\\n    coord_t b[DIMS];\\n    coord_t alpha = 0;\\n\\n    for (int d = 0; d &lt; DIMS; d++) {\\n\\n        // subtract \"start\" from \"end\" and \"point\" to get \"a\" and \"b\"\\n        a[d] = end[d] - start[d];\\n        b[d] = point[d] - start[d];\\n\\n        // compute dot product \"alpha\" of \"a\" and \"b\"\\n        alpha += a[d] * b[d];\\n    }\\n\\n    // normalize dot product\\n    alpha /= length2(a);\\n\\n    // clip at 0 and 1 (beginning and end of line segment)\\n    alpha = min0(1, max0(0, alpha));\\n\\n    for (int d = 0; d &lt; DIMS; d++) {\\n\\n        // multiply \"a\" by \"alpha\" to obtain closest segment point to \"b\"\\n        a[d] *= alpha;\\n\\n        // subtract \"b\" from \"a\" to get offset\\n        a[d] -= b[d];\\n    }\\n\\n    // compute squared length of offset\\n    return length2(a);\\n}\\n\\nextern inline coord_t distance(\\n    const coord_t point[], const struct rect *rect, const struct item_t item) {\\n    coord_t start[DIMS];\\n    coord_t end[DIMS];\\n    for (int d = 0; d &lt; DIMS; d++) {\\n        if (item.corner_mask[d]) {\\n            start[d] = rect-&gt;min[d];\\n            end[d] = rect-&gt;max[d];\\n        } else {\\n            start[d] = rect-&gt;max[d];\\n            end[d] = rect-&gt;min[d];\\n        }\\n    }\\n    return point_segment_dist2(point, start, end);\\n}\\n'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_equal_function","title":"c_equal_function  <code>class</code>","text":"<pre><code>c_equal_function = \"\\ninline int equal(const item_t a, const item_t b) {\\n    return (a.u == b.u &amp;&amp; a.v == b.v);\\n}\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.c_item_t_declaration","title":"c_item_t_declaration  <code>class</code>","text":"<pre><code>c_item_t_declaration = \"\\ntypedef struct item_t {\\n    item_base_t u;\\n    item_base_t v;\\n    bool corner_mask[DIMS];\\n} item_t;\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.pyx_item_t_declaration","title":"pyx_item_t_declaration  <code>class</code>","text":"<pre><code>pyx_item_t_declaration = \"\\n    cdef struct item_t:\\n        item_base_t u\\n        item_base_t v\\n        bool corner_mask[DIMS]\\n\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.delete_item","title":"delete_item","text":"<pre><code>delete_item(item, bb_min, bb_max=None)\n</code></pre> <p>Delete a single item.</p> <p>To delete multiple items, use <code>delete_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def delete_item(self, item, bb_min, bb_max=None):\n    \"\"\"Delete a single item.\n\n    To delete multiple items, use `delete_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    bb_mins = bb_min[np.newaxis, :]\n    bb_maxs = None if bb_max is None else bb_max[np.newaxis, :]\n    return self.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line","title":"insert_line","text":"<pre><code>insert_line(line, start, end)\n</code></pre> <p>Convenience function to insert a single line. To insert multiple lines in bulk, please use the faster <code>insert_lines</code>.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_rtree/line_rtree.py</code> <pre><code>def insert_line(self, line, start, end):\n    \"\"\"Convenience function to insert a single line. To insert multiple\n    lines in bulk, please use the faster `insert_lines`.\n\n    Parameters\n    ----------\n    line : np.ndarray\n        The line identifier (as passed as the `item_dtype` to the\n        constructor).\n    start : np.ndarray\n        The coordinates of the start of the line.\n    end : np.ndarray\n        The coordinates of the end of the line.\n    \"\"\"\n    lines = np.array([line], dtype=self.item_dtype.base)\n    starts = start[np.newaxis]\n    ends = end[np.newaxis]\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line(line)","title":"<code>line</code>","text":"(<code>ndarray</code>)           \u2013            <p>The line identifier (as passed as the <code>item_dtype</code> to the constructor).</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line(start)","title":"<code>start</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the start of the line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_line(end)","title":"<code>end</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the end of the line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines","title":"insert_lines","text":"<pre><code>insert_lines(lines, starts, ends)\n</code></pre> <p>Insert a list of lines.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_rtree/line_rtree.py</code> <pre><code>def insert_lines(self, lines, starts, ends):\n    \"\"\"Insert a list of lines.\n\n    Parameters\n    ----------\n    lines : np.ndarray, shape `(n, [m])`:\n        Array containing the line identifiers (as passed as the\n        `item_dtype` to the constructor). If the identifiers are an\n        array of size `m`, the expected shape is `(n, m)` where `n` is\n        the number of lines, otherwise the shape is just `(n,)`.\n\n    starts : np.ndarray, shape `(n, d)`:\n        The coordinates of the start of each line.\n\n    ends : np.ndarray, shape `(n, d)`:\n        The coordinates of the end of each line.\n    \"\"\"\n    # we just forward to bb insert, \"start\" and \"end\" will be used to compute\n    # the bounding box in our custom converter above\n    return self.insert_bb_items(lines, starts, ends)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines(lines)","title":"<code>lines</code>","text":"(<code>np.ndarray, shape `(n, [m])`:</code>)           \u2013            <p>Array containing the line identifiers (as passed as the <code>item_dtype</code> to the constructor). If the identifiers are an array of size <code>m</code>, the expected shape is <code>(n, m)</code> where <code>n</code> is the number of lines, otherwise the shape is just <code>(n,)</code>.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines(starts)","title":"<code>starts</code>","text":"(<code>np.ndarray, shape `(n, d)`:</code>)           \u2013            <p>The coordinates of the start of each line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_lines(ends)","title":"<code>ends</code>","text":"(<code>np.ndarray, shape `(n, d)`:</code>)           \u2013            <p>The coordinates of the end of each line.</p>"},{"location":"reference/spatial_graph/#spatial_graph.LineRTree.insert_point_item","title":"insert_point_item","text":"<pre><code>insert_point_item(item, position)\n</code></pre> <p>Insert a single point item.</p> <p>To insert multiple points, use <code>insert_point_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_point_item(self, item, position):\n    \"\"\"Insert a single point item.\n\n    To insert multiple points, use `insert_point_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    positions = position[np.newaxis]\n    return self.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree","title":"PointRTree","text":"<pre><code>PointRTree(item_dtype, coord_dtype, dims)\n</code></pre> <p>               Bases: <code>spatial_graph._rtree.rtree.RTree</code></p> <p>Methods:</p> <ul> <li> <code>delete_item</code>             \u2013              <p>Delete a single item.</p> </li> <li> <code>insert_point_item</code>             \u2013              <p>Insert a single point item.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>c_converter_functions</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_distance_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_equal_function</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>c_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> <li> <code>pyx_item_t_declaration</code>           \u2013            <p>str(object='') -&gt; str</p> </li> </ul> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def __init__(self, item_dtype, coord_dtype, dims):\n    super().__init__()\n    self.item_dtype = DType(item_dtype)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_converter_functions","title":"c_converter_functions  <code>class</code>","text":"<pre><code>c_converter_functions = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_distance_function","title":"c_distance_function  <code>class</code>","text":"<pre><code>c_distance_function = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_equal_function","title":"c_equal_function  <code>class</code>","text":"<pre><code>c_equal_function = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.c_item_t_declaration","title":"c_item_t_declaration  <code>class</code>","text":"<pre><code>c_item_t_declaration = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.pyx_item_t_declaration","title":"pyx_item_t_declaration  <code>class</code>","text":"<pre><code>pyx_item_t_declaration = ''\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.delete_item","title":"delete_item","text":"<pre><code>delete_item(item, bb_min, bb_max=None)\n</code></pre> <p>Delete a single item.</p> <p>To delete multiple items, use <code>delete_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def delete_item(self, item, bb_min, bb_max=None):\n    \"\"\"Delete a single item.\n\n    To delete multiple items, use `delete_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    bb_mins = bb_min[np.newaxis, :]\n    bb_maxs = None if bb_max is None else bb_max[np.newaxis, :]\n    return self.delete_items(items, bb_mins, bb_maxs)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.PointRTree.insert_point_item","title":"insert_point_item","text":"<pre><code>insert_point_item(item, position)\n</code></pre> <p>Insert a single point item.</p> <p>To insert multiple points, use <code>insert_point_items</code>.</p> Source code in <code>src/spatial_graph/_rtree/rtree.py</code> <pre><code>def insert_point_item(self, item, position):\n    \"\"\"Insert a single point item.\n\n    To insert multiple points, use `insert_point_items`.\n    \"\"\"\n    items = np.array([item], dtype=self.item_dtype.base)\n    positions = position[np.newaxis]\n    return self.insert_point_items(items, positions)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph","title":"SpatialDiGraph","text":"<pre><code>SpatialDiGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._spatial_graph.SpatialGraphBase</code>, <code>spatial_graph._graph.graph.DiGraph</code></p> <p>Base class for directed spatial graph instances.</p> <p>Attributes:</p> <ul> <li> <code>edge_inclusion_values</code>           \u2013            <p>Built-in mutable sequence.</p> </li> </ul> Source code in <code>src/spatial_graph/_spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialDiGraph.edge_inclusion_values","title":"edge_inclusion_values  <code>class</code>","text":"<pre><code>edge_inclusion_values = ['incident', 'leaving', 'entering']\n</code></pre> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph","title":"SpatialGraph","text":"<pre><code>SpatialGraph(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._spatial_graph.SpatialGraphBase</code>, <code>spatial_graph._graph.graph.Graph</code></p> <p>Base class for undirected spatial graph instances.</p> <p>Attributes:</p> <ul> <li> <code>edge_inclusion_values</code>           \u2013            <p>Built-in mutable sequence.</p> </li> </ul> Source code in <code>src/spatial_graph/_spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraph.edge_inclusion_values","title":"edge_inclusion_values  <code>class</code>","text":"<pre><code>edge_inclusion_values = ['incident', 'leaving', 'entering']\n</code></pre> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase","title":"SpatialGraphBase","text":"<pre><code>SpatialGraphBase(\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n)\n</code></pre> <p>               Bases: <code>spatial_graph._graph.graph.GraphBase</code></p> <p>Attributes:</p> <ul> <li> <code>edge_inclusion_values</code>           \u2013            <p>Built-in mutable sequence.</p> </li> </ul> Source code in <code>src/spatial_graph/_spatial_graph.py</code> <pre><code>def __init__(\n    self,\n    ndims: int,\n    node_dtype: str,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str = \"position\",\n    directed: bool = False,\n) -&gt; None:\n    node_attr_dtypes = node_attr_dtypes or {}\n    if position_attr not in node_attr_dtypes:\n        raise ValueError(\n            f\"position attribute {position_attr!r} not defined in \"\n            \"'node_attr_dtypes'\"\n        )\n    super().__init__(node_dtype, node_attr_dtypes, edge_attr_dtypes, directed)\n\n    self.ndims = ndims\n    self.position_attr = position_attr\n    self.coord_dtype = DType(node_attr_dtypes[position_attr]).base\n    self._node_rtree: Any = PointRTree(node_dtype, self.coord_dtype, ndims)\n    self._edge_rtree: Any = LineRTree(f\"{node_dtype}[2]\", self.coord_dtype, ndims)\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.SpatialGraphBase.edge_inclusion_values","title":"edge_inclusion_values  <code>class</code>","text":"<pre><code>edge_inclusion_values = ['incident', 'leaving', 'entering']\n</code></pre> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph","title":"create_graph","text":"<pre><code>create_graph(\n    node_dtype: str,\n    ndims: int | None = None,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str | None = None,\n    directed: bool = False,\n) -&gt; Graph | DiGraph | SpatialGraph | SpatialDiGraph\n</code></pre> <p>Convenience factory function to create a graph instance.</p> <p>This will create the appropriate graph type based on the parameters provided. If <code>ndims</code> is specified, it will create a spatial graph; otherwise, it will create a non-spatial graph. If <code>directed</code> is True, it will create a directed graph; otherwise, it will create an undirected graph.</p> <p>Parameters:</p> Source code in <code>src/spatial_graph/_util.py</code> <pre><code>def create_graph(\n    node_dtype: str,\n    ndims: int | None = None,\n    node_attr_dtypes: Mapping[str, str] | None = None,\n    edge_attr_dtypes: Mapping[str, str] | None = None,\n    position_attr: str | None = None,\n    directed: bool = False,\n) -&gt; Graph | DiGraph | SpatialGraph | SpatialDiGraph:\n    \"\"\"Convenience factory function to create a graph instance.\n\n    This will create the appropriate graph type based on the parameters provided.\n    If `ndims` is specified, it will create a spatial graph; otherwise, it will create\n    a non-spatial graph. If `directed` is True, it will create a directed graph;\n    otherwise, it will create an undirected graph.\n\n    Parameters\n    ----------\n    node_dtype : str\n        The data type of the nodes in the graph.\n    ndims : int or None, optional\n        The number of dimensions for spatial graphs. If None, the graph is non-spatial.\n    node_attr_dtypes : Mapping[str, str], optional\n        A mapping of node attribute names to their data types.\n    edge_attr_dtypes : Mapping[str, str], optional\n        A mapping of edge attribute names to their data types.\n    position_attr : str, optional\n        The name of the attribute that holds the position of nodes in spatial graphs.\n    directed : bool, optional\n        Whether the graph is directed or not. Defaults to False.\n    \"\"\"\n    if ndims is not None:  # Spatial graph\n        cls = SpatialDiGraph if directed else SpatialGraph\n        return cls(\n            ndims=ndims,\n            node_dtype=node_dtype,\n            node_attr_dtypes=node_attr_dtypes,\n            edge_attr_dtypes=edge_attr_dtypes,\n            position_attr=position_attr or \"position\",\n        )\n    else:\n        if position_attr is not None:  # pragma: no cover\n            warnings.warn(\n                \"'position_attr' is ignored when 'ndims' is not specified.\",\n                UserWarning,\n                stacklevel=2,\n            )\n\n        cls_ = DiGraph if directed else Graph\n        return cls_(\n            node_dtype=node_dtype,\n            node_attr_dtypes=node_attr_dtypes,\n            edge_attr_dtypes=edge_attr_dtypes,\n        )\n</code></pre>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(node_dtype)","title":"<code>node_dtype</code>","text":"(<code>str</code>)           \u2013            <p>The data type of the nodes in the graph.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(ndims)","title":"<code>ndims</code>","text":"(<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>The number of dimensions for spatial graphs. If None, the graph is non-spatial.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(node_attr_dtypes)","title":"<code>node_attr_dtypes</code>","text":"(<code>Mapping[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of node attribute names to their data types.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(edge_attr_dtypes)","title":"<code>edge_attr_dtypes</code>","text":"(<code>Mapping[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of edge attribute names to their data types.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the attribute that holds the position of nodes in spatial graphs.</p>"},{"location":"reference/spatial_graph/#spatial_graph.create_graph(directed)","title":"<code>directed</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the graph is directed or not. Defaults to False.</p>"}]}